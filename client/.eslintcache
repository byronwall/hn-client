[{"/Users/byronwall/Projects/hn-node/client/src/index.tsx":"1","/Users/byronwall/Projects/hn-node/client/src/serviceWorker.ts":"2","/Users/byronwall/Projects/hn-node/client/src/App.tsx":"3","/Users/byronwall/Projects/hn-node/client/src/DataLayer.tsx":"4","/Users/byronwall/Projects/hn-node/client/src/Header.tsx":"5","/Users/byronwall/Projects/hn-node/client/src/HnStoryList.tsx":"6","/Users/byronwall/Projects/hn-node/client/src/HnStoryPage.tsx":"7","/Users/byronwall/Projects/hn-node/client/src/HnComment.tsx":"8","/Users/byronwall/Projects/hn-node/client/src/HnListItem.tsx":"9","/Users/byronwall/Projects/hn-node/client/src/getDomain.tsx":"10","/Users/byronwall/Projects/hn-node/client/src/HnCommentList.tsx":"11","/Users/byronwall/Projects/hn-node/client/src/SearchPopup.tsx":"12","/Users/byronwall/Projects/hn-node/client/src/helpers.ts":"13","/Users/byronwall/Projects/hn-node/client/src/InfiniteScrollContainer.tsx":"14","/Users/byronwall/Projects/hn-node/client/src/timeSince.ts":"15"},{"size":1458,"mtime":1609990818215,"results":"16","hashOfConfig":"17"},{"size":5198,"mtime":1545100494667,"results":"18","hashOfConfig":"17"},{"size":6341,"mtime":1620361788187,"results":"19","hashOfConfig":"17"},{"size":9814,"mtime":1620361749236,"results":"20","hashOfConfig":"17"},{"size":1963,"mtime":1620360684800,"results":"21","hashOfConfig":"17"},{"size":1646,"mtime":1623980053927,"results":"22","hashOfConfig":"17"},{"size":5641,"mtime":1624760334215,"results":"23","hashOfConfig":"17"},{"size":3836,"mtime":1623980494222,"results":"24","hashOfConfig":"17"},{"size":1454,"mtime":1620361871022,"results":"25","hashOfConfig":"17"},{"size":224,"mtime":1620360729852,"results":"26","hashOfConfig":"17"},{"size":2470,"mtime":1623980415226,"results":"27","hashOfConfig":"17"},{"size":2223,"mtime":1620361693284,"results":"28","hashOfConfig":"17"},{"size":717,"mtime":1609988632867,"results":"29","hashOfConfig":"17"},{"size":2078,"mtime":1620360321975,"results":"30","hashOfConfig":"17"},{"size":688,"mtime":1620361760798,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"35"},"1qotfuo",{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"35"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"35"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"35"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"35"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"35"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},"/Users/byronwall/Projects/hn-node/client/src/index.tsx",["70","71","72","73"],"import \"@blueprintjs/core/lib/css/blueprint.css\";\n\nimport localForage from \"localforage\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter, Route } from \"react-router-dom\";\nimport smoothscroll from \"smoothscroll-polyfill\";\n\nimport { App } from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport { Provider } from \"unstated\";\nimport { DataLayer } from \"./DataLayer\";\n\n// kick off the polyfill!\nsmoothscroll.polyfill();\n\nwindow.onerror = function (msg, url, lineNo, columnNo, error) {\n  // ... handle error ...\n  console.error(\"major error\", msg);\n  localForage.clear();\n\n  document.body.innerHTML =\n    \"<h1>major error occurred.  local storage cleared to avoid corruption. please refresh.</h1>\";\n};\n\n// check if version exists\nconst version = localStorage.getItem(\"VERSION\");\nif (version === null) {\n  localForage.clear();\n}\n\nlocalStorage.setItem(\"VERSION\", \"1.0\");\n\nexport const GLOBAL_DATA_LAYER = new DataLayer();\n\nReactDOM.render(\n  <BrowserRouter>\n    <Route path={[\"/story/:storyId\", \"/search/:searchTerm\", \"/:page?\"]}>\n      <Provider inject={[GLOBAL_DATA_LAYER]}>\n        <App />\n      </Provider>\n    </Route>\n  </BrowserRouter>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.register();\n",[],"/Users/byronwall/Projects/hn-node/client/src/serviceWorker.ts",[],"/Users/byronwall/Projects/hn-node/client/src/App.tsx",[],"/Users/byronwall/Projects/hn-node/client/src/DataLayer.tsx",["74","75"],"import localforage from \"localforage\";\nimport _ from \"lodash\";\nimport { Container } from \"unstated\";\n\nimport { HnListSource, TrueHash } from \"./App\";\nimport { SESSION_COLLAPSED } from \"./HnStoryPage\";\n\ninterface DataLayerState {\n  activeListType: HnListSource | undefined;\n\n  activeList: HnStorySummary[];\n\n  isLoadingNewData: boolean;\n  isLoadingLocalStorage: boolean;\n\n  readItems: TrueHash;\n\n  storyKey: number;\n}\n\nexport interface DataList {\n  key: HnListSource;\n\n  storyHeadlines: HnStorySummary[];\n}\n\nexport interface HnStorySummary {\n  title: string;\n  score: number;\n  id: number;\n  url: string | undefined;\n  commentCount: number | undefined;\n  time: number;\n}\n\nconst LOCAL_READ_ITEMS = \"STORAGE_READ_ITEMS\";\nexport class DataLayer extends Container<DataLayerState> {\n  pendingReadItems: number[] = [];\n\n  constructor() {\n    super();\n\n    // run through some initial stuff?\n\n    this.initializeFromLocalStorage();\n    // load from local storage on creation\n\n    this.state = {\n      isLoadingNewData: false,\n      activeList: [],\n\n      isLoadingLocalStorage: true,\n\n      readItems: {},\n      activeListType: undefined,\n\n      storyKey: 0,\n    };\n  }\n\n  async executeSearch(searchTerm: string) {\n    console.log(\"execute search\", searchTerm);\n\n    // get the stories\n    this.updateIsLoadingStatus(true);\n    const storyData = await this.api_getSearchResults(searchTerm);\n\n    if (storyData === undefined) {\n      this.updateIsLoadingStatus(false);\n      return;\n    }\n\n    console.log(\"search results\", storyData);\n\n    this.updateIsLoadingStatus(false);\n\n    this.setState({\n      activeList: storyData,\n      activeListType: HnListSource.Search,\n    });\n\n    // update the story list\n  }\n\n  async initializeFromLocalStorage() {\n    console.log(\"loading from local storage\");\n    this.setState({ isLoadingLocalStorage: true });\n\n    // add the promise so that others can await them too\n\n    const readItems = await localforage.getItem<TrueHash>(LOCAL_READ_ITEMS);\n\n    console.log(\"loaded from local storage\");\n\n    this.setState({\n      isLoadingLocalStorage: false,\n      readItems: readItems ?? {},\n    });\n\n    this.pendingReadItems.forEach((id) => this.saveIdToReadList(id));\n    this.pendingReadItems = [];\n\n    if (this.state.activeListType !== undefined) {\n      this.updateActiveList(this.state.activeListType);\n    }\n\n    this.pruneLocalStorage();\n  }\n  async pruneLocalStorage() {\n    // this will go through the known lists and remove any stories that are not needed now\n\n    const keys = await localforage.keys();\n\n    const listProm = keys\n      .filter((key) => key.startsWith(\"STORIES_\"))\n      .map((key) => {\n        return localforage.getItem<HnStorySummary[]>(key);\n      });\n\n    const storyLists = await Promise.all(listProm);\n\n    const allKnownIds = _.flatten(storyLists)\n      .filter((c) => c !== null)\n      .map((c) => c!.id + \"\");\n\n    // remove those ids from the keys array above\n\n    const keysToRemove = keys\n      .filter((c) => !c.startsWith(\"STORIES_\"))\n      .filter((c) => c !== LOCAL_READ_ITEMS)\n      .filter((c) => !_.includes(allKnownIds, c));\n\n    console.log(\"going to prune\", keysToRemove);\n\n    keysToRemove.forEach((c) => localforage.removeItem(c));\n  }\n\n  saveIdToReadList = (id: number) => {\n    if (this.state.isLoadingLocalStorage) {\n      // don't save data before list is loaded --- will clear it\n      console.log(\"do not update read list... pending updates\");\n      this.pendingReadItems.push(id);\n      return;\n    }\n    const newReadList = _.cloneDeep(this.state.readItems);\n    console.log(\"new read list\", newReadList);\n\n    // skip out if already there\n    if (newReadList[id]) {\n      return;\n    }\n\n    newReadList[id] = true;\n\n    localforage.setItem(LOCAL_READ_ITEMS, newReadList);\n\n    // ensure the new item is taken\n    this.setState(() => {\n      return { readItems: newReadList };\n    });\n  };\n\n  async getStoryData(id: number) {\n    // load story from local storage or server\n    const item = await localforage.getItem<HnItem>(id + \"\");\n\n    if (item !== null) {\n      return item;\n    }\n\n    // hit the API for the story data\n    return await this.getStoryFromServer(id);\n  }\n\n  public async api_getSearchResults(query: string) {\n    const url = \"/api/search/\" + encodeURIComponent(query);\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      return undefined;\n    }\n    const data: HnStorySummary[] | { error: string } = await response.json();\n\n    if (\"error\" in data) {\n      console.error(data);\n\n      return undefined;\n    }\n\n    console.log(\"hn item from search\", data);\n\n    return data;\n  }\n\n  public async getStoryFromServer(id: number) {\n    const url = \"/api/story/\" + id;\n\n    this.updateIsLoadingStatus(true);\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      return undefined;\n    }\n    const data: HnItem | { error: string } = await response.json();\n\n    if (\"error\" in data) {\n      console.error(data);\n      this.updateIsLoadingStatus(false);\n      return undefined;\n    }\n\n    console.log(\"hn item from server\", data);\n\n    this.updateIsLoadingStatus(false);\n\n    // ensure new story is saved locally\n    localforage.setItem(id + \"\", data);\n\n    return data;\n  }\n  updateIsLoadingStatus(isLoading: boolean) {\n    this.setState({ isLoadingNewData: isLoading });\n  }\n\n  async reloadStoryById(id: number) {\n    await this.clearItemData(id);\n\n    // this should force a render of the story page\n    this.setState((prevState) => {\n      return { storyKey: prevState.storyKey + 1 };\n    });\n  }\n\n  async clearItemData(id: number) {\n    const itemRemoved = await localforage.getItem<HnItem>(id + \"\");\n\n    if (itemRemoved === null) {\n      return;\n    }\n\n    await localforage.removeItem(id + \"\");\n\n    // need to clear any collpased ids also\n    if (itemRemoved !== undefined) {\n      // get all child ids\n\n      const itemsToCheck: (HnItem | KidsObj3)[] = [itemRemoved];\n\n      const strIds = sessionStorage.getItem(SESSION_COLLAPSED);\n\n      if (strIds !== null) {\n        const collapsedIds = JSON.parse(strIds) as number[];\n\n        const collapseHash = new Set(collapsedIds);\n\n        while (itemsToCheck.length) {\n          const item = itemsToCheck.shift();\n\n          if (item === undefined) {\n            continue;\n          }\n\n          // remove if collapsed\n          if (collapseHash.has(item.id)) {\n            collapseHash.delete(item.id);\n          }\n\n          item.kidsObj\n            ?.filter((c) => c !== null)\n            .forEach((c) => itemsToCheck.push(c!));\n        }\n\n        const newCollapse = Array.from(collapseHash);\n\n        console.log(\"old collapse\", collapsedIds, newCollapse);\n\n        sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newCollapse));\n      }\n    }\n  }\n\n  async updateActiveList(source: HnListSource) {\n    // TODO: add loading step if data is missing -- figure out how to trigger refresh\n\n    this.setState({ activeListType: source });\n\n    console.log(\"getpagedata\", source, this.state);\n\n    if (source === undefined) {\n      console.error(\"unknown page -> source map\");\n      this.setState({ activeList: [] });\n      return [];\n    }\n\n    // load the story list from local storage if possible\n    const summariesForType = await localforage.getItem<HnStorySummary[]>(\n      \"STORIES_\" + source\n    );\n\n    if (summariesForType === null) {\n      console.log(\"no ids to load...\");\n      this.reloadStoryListFromServer(source);\n      return;\n    }\n\n    let dataOut = summariesForType;\n\n    if (source !== HnListSource.Front) {\n      dataOut = _.sortBy(dataOut, (c) => -c.score);\n    }\n\n    this.setState({ activeList: dataOut });\n  }\n\n  public async reloadStoryListFromServer(activeList: HnListSource) {\n    console.log(\"loading data\");\n    let url = \"\";\n    switch (activeList) {\n      case HnListSource.Front:\n        url = \"/topstories/topstories\";\n        break;\n      case HnListSource.Day:\n        url = \"/topstories/day\";\n        break;\n      case HnListSource.Week:\n        url = \"/topstories/week\";\n        break;\n      case HnListSource.Month:\n        url = \"/topstories/month\";\n        break;\n    }\n\n    if (this.state.isLoadingNewData) {\n      console.log(\"only have one request at a time\");\n      return;\n    }\n\n    this.updateIsLoadingStatus(true);\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      this.updateIsLoadingStatus(false);\n\n      return;\n    }\n    let data: HnItem[] = await response.json();\n\n    if (activeList !== HnListSource.Front) {\n      // flip score to get descending\n      data = _.sortBy<HnItem>(data, (c) => -c.score);\n    }\n\n    // TODO: take that list of items and set it equal to the current list\n    // TODO: update the items with a merge of sorts instead of overwriting\n\n    console.log(\"hn items from server\", data);\n\n    this.updateIsLoadingStatus(false);\n\n    this.updateNewItems(data, activeList);\n  }\n\n  updateNewItems(data: HnItem[] | undefined, listType: HnListSource): void {\n    console.log(\"items coming from server\", data, listType, this.state);\n\n    if (data === undefined) {\n      data = [];\n    }\n\n    // replace the list with the new IDs\n    const storySummaries: HnStorySummary[] = data.map<HnStorySummary>((c) => {\n      return {\n        id: c.id,\n        score: c.score,\n        title: c.title,\n        url: c.url,\n        commentCount: c.descendants,\n        time: c.time,\n      };\n    });\n\n    //  push each item in localforage under its own key\n\n    data.forEach((newStory) => {\n      localforage.setItem(newStory.id + \"\", newStory);\n    });\n\n    // also save the new list to localfoeage\n    localforage.setItem(\"STORIES_\" + listType, storySummaries);\n\n    // update otherwise\n\n    this.setState({\n      activeList: storySummaries,\n    });\n  }\n}\n","/Users/byronwall/Projects/hn-node/client/src/Header.tsx",[],"/Users/byronwall/Projects/hn-node/client/src/HnStoryList.tsx",["76"],"import { Spinner } from \"@blueprintjs/core\";\nimport { History } from \"history\";\nimport React from \"react\";\n\nimport { TrueHash } from \"./App\";\nimport { HnStorySummary } from \"./DataLayer\";\nimport { HnListItem } from \"./HnListItem\";\n\ninterface HnStoryListProps {\n  items: HnStorySummary[];\n  readIds: TrueHash;\n  history: History;\n  isLoading: boolean;\n}\n\nconst SESSION_SCROLL = \"SCROLL_LIST\";\nexport class HnStoryList extends React.PureComponent<HnStoryListProps> {\n  constructor(props: HnStoryListProps) {\n    super(props);\n    this.state = {};\n  }\n\n  componentDidMount() {\n    this.scrollToPrevious();\n  }\n\n  private scrollToPrevious() {\n    const { history } = this.props;\n\n    if (history.action === \"POP\") {\n      // restore scroll pos if available\n      const scrollPos = +sessionStorage.getItem(SESSION_SCROLL)!;\n\n      if (!isNaN(scrollPos)) {\n        console.log(\"fire off scroll\", scrollPos);\n        window.scrollTo({ top: scrollPos });\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    console.log(\"save scroll pos\", window.scrollY);\n\n    sessionStorage.setItem(SESSION_SCROLL, \"\" + window.scrollY);\n  }\n\n  render() {\n    const { items, isLoading, readIds } = this.props;\n\n    document.title = `HN: Offline`;\n\n    const spinner =\n      items.length === 0 && isLoading ? (\n        <div style={{ marginTop: 20 }}>\n          <Spinner size={200} intent=\"warning\" />\n        </div>\n      ) : null;\n\n    return (\n      <div>\n        {spinner}\n        <div id=\"list-holder\">\n          {items.map((item) => (\n            <HnListItem data={item} key={item.id} isRead={readIds[item.id]} />\n          ))}\n        </div>\n      </div>\n    );\n  }\n}\n","/Users/byronwall/Projects/hn-node/client/src/HnStoryPage.tsx",["77"],"import { Button, H2, H4 } from \"@blueprintjs/core\";\nimport { History } from \"history\";\nimport _ from \"lodash\";\nimport React from \"react\";\n\nimport { GLOBAL_DATA_LAYER } from \".\";\nimport { getDomain } from \"./getDomain\";\nimport { isValidComment } from \"./HnComment\";\nimport { HnCommentList } from \"./HnCommentList\";\nimport { timeSince } from \"./timeSince\";\n\nimport dummyItem from \"./dummyItem.json\";\n\ninterface HnStoryPageState {\n  collapsedComments: number[];\n  idToScrollTo: number | undefined;\n\n  data: HnItem | undefined | null;\n}\n\nexport interface HnStoryPageProps {\n  id: number | undefined;\n  history: History;\n\n  onVisitMarker(id: number): void;\n}\n\nexport const SESSION_COLLAPSED = \"SESSION_COLLAPSED\";\nexport class HnStoryPage extends React.PureComponent<\n  HnStoryPageProps,\n  HnStoryPageState\n> {\n  constructor(props: HnStoryPageProps) {\n    super(props);\n\n    this.state = {\n      collapsedComments: [],\n      idToScrollTo: undefined,\n      data: undefined,\n    };\n\n    this.anchorClickHandler = this.anchorClickHandler.bind(this);\n  }\n\n  render() {\n    const { data, idToScrollTo, collapsedComments } = this.state;\n    const isSkeleton = data === undefined;\n    const storyData = data ?? (dummyItem as HnItem);\n\n    // add this line to remove the state info on scrolling -- prevent scroll on reload\n    if (idToScrollTo) {\n      this.setState({ idToScrollTo: undefined });\n    }\n\n    const storyLinkEl =\n      storyData.url === undefined ? (\n        <span>{storyData.title}</span>\n      ) : (\n        <a href={storyData.url}>{storyData.title}</a>\n      );\n\n    const comments = (storyData.kidsObj || []).filter(isValidComment);\n\n    document.title = `HN: ${storyData.title}`;\n\n    const classMod = {\n      className: isSkeleton ? \"bp3-skeleton\" : undefined,\n    };\n\n    return (\n      <div>\n        <H2 style={{ overflowWrap: \"break-word\" }} {...classMod}>\n          {storyLinkEl}\n        </H2>\n        <H4>\n          <span {...classMod}>{storyData.by}</span>\n          <span>{\" | \"}</span>\n          <span {...classMod}>\n            {storyData.score}\n            {\" points\"}\n          </span>\n          <span>{\" | \"}</span>\n          <span {...classMod}>{timeSince(storyData.time)} ago</span>\n          <span>{\" | \"}</span>\n          <span {...classMod}>{getDomain(storyData.url)}</span>\n\n          {navigator.share && (\n            <>\n              <span>{\" | \"}</span>\n              <Button icon=\"share\" onClick={this.handleShareClick} minimal />\n            </>\n          )}\n        </H4>\n        {storyData.text !== undefined && (\n          <p\n            className=\"top-text\"\n            dangerouslySetInnerHTML={{ __html: storyData.text }}\n          />\n        )}\n\n        <HnCommentList\n          childComments={comments}\n          depth={0}\n          collapsedIds={collapsedComments}\n          onUpdateOpen={this.handleCollapseEvent}\n          idToScrollTo={idToScrollTo}\n          isSkeleton={isSkeleton}\n        />\n      </div>\n    );\n  }\n\n  private handleShareClick = () => {\n    navigator.share({ url: window.location.href });\n  };\n\n  private handleCollapseEvent = (\n    id: number,\n    newOpen: boolean,\n    scrollId: number | undefined\n  ) => {\n    // save the id to session storage\n    const { collapsedComments } = this.state;\n    if (newOpen) {\n      // remove from list\n      const newIds = _.cloneDeep(collapsedComments);\n      _.remove(newIds, (c) => c === id);\n\n      sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newIds));\n      this.setState({ collapsedComments: newIds });\n    } else {\n      const newIds = collapsedComments.concat(id);\n\n      sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newIds));\n      this.setState({ collapsedComments: newIds });\n    }\n\n    if (scrollId !== undefined) {\n      this.setState({ idToScrollTo: scrollId });\n    }\n  };\n\n  componentDidMount() {\n    const { id, onVisitMarker } = this.props;\n\n    window.scrollTo({ top: 0 });\n\n    // set the data initially -- kick off async request if needed\n\n    document.body.addEventListener(\"click\", this.anchorClickHandler);\n\n    const strCollapsedIds = sessionStorage.getItem(SESSION_COLLAPSED);\n    // load the collapsed comments from session storage\n\n    if (strCollapsedIds !== null) {\n      const collapsedIds = JSON.parse(strCollapsedIds) as number[];\n\n      this.setState({ collapsedComments: collapsedIds });\n    }\n\n    // save the read stories to localForage\n\n    if (id !== undefined) {\n      onVisitMarker(id);\n    }\n\n    // load the story data\n\n    this.loadStoryData();\n  }\n\n  componentDidUpdate(prevProps: HnStoryPageProps) {\n    const { id } = this.props;\n    const didIdChange = id !== prevProps.id;\n\n    if (didIdChange) {\n      this.loadStoryData();\n    }\n  }\n\n  async loadStoryData() {\n    const { id } = this.props;\n    // take the ID, get the story, send to state\n\n    // TODO: why is this ever undefined?\n\n    if (id === undefined) {\n      return;\n    }\n\n    const storyData = await GLOBAL_DATA_LAYER.getStoryData(id);\n\n    this.setState({ data: storyData });\n  }\n\n  componentWillUnmount() {\n    document.body.removeEventListener(\"click\", this.anchorClickHandler);\n  }\n  anchorClickHandler(e: any) {\n    const { history } = this.props;\n    if (e.target.tagName !== \"A\") {\n      return;\n    }\n\n    // have a link\n\n    const link = e.target as HTMLAnchorElement;\n\n    const regex = /https?:\\/\\/news\\.ycombinator\\.com\\/item\\?id=(\\d+)/;\n    const matches = link.href.match(regex);\n\n    if (matches === null) {\n      link.target = \"_blank\";\n      return;\n    }\n\n    // this will navigate to the new page\n    history.push(\"/story/\" + matches[1]);\n\n    e.preventDefault();\n    return false;\n  }\n}\n","/Users/byronwall/Projects/hn-node/client/src/HnComment.tsx",["78"],"import classNames from \"classnames\";\nimport React from \"react\";\n\nimport { HnCommentList } from \"./HnCommentList\";\nimport { timeSince } from \"./timeSince\";\n\nexport interface HnCommentProps {\n  comment: KidsObj3 | null;\n  depth: number;\n\n  isOpen: boolean;\n  onUpdateOpen(\n    id: number,\n    newIsOpen: boolean,\n    scrollId: number | undefined,\n    comment: KidsObj3 | null,\n    nextChildId: number | undefined\n  ): void;\n  collapsedIds: number[];\n  idToScrollTo: number | undefined;\n  nextChildId: number | undefined;\n}\n\nconst colors = [\n  \"#bc8672\",\n  \"#c5be53\",\n  \"#d46850\",\n  \"#8c7f3b\",\n  \"#dec392\",\n  \"#c9893a\",\n];\n\nexport class HnComment extends React.Component<HnCommentProps> {\n  divRef: React.RefObject<HTMLDivElement>;\n\n  componentDidMount() {\n    this.scrollIfDesired();\n  }\n\n  componentDidUpdate() {\n    this.scrollIfDesired();\n  }\n\n  scrollIfDesired() {\n    const { idToScrollTo, comment } = this.props;\n    if (idToScrollTo === comment?.id) {\n      const dims = this.divRef.current?.offsetTop;\n      console.log(\"scrolling to me\", dims);\n\n      if (dims !== undefined) {\n        window.scrollTo({ behavior: \"smooth\", top: dims - 80 });\n      }\n    }\n  }\n\n  constructor(props: HnCommentProps) {\n    super(props);\n\n    this.divRef = React.createRef();\n  }\n\n  getDivRef() {\n    if (this.divRef.current === null) {\n      throw new Error(\"should not be null\");\n    }\n    return this.divRef.current;\n  }\n\n  render() {\n    const { idToScrollTo, comment, isOpen, depth, onUpdateOpen, collapsedIds } =\n      this.props;\n\n    if (comment === null) {\n      return null;\n    }\n\n    // TODO: don't modify this array here\n    const childComments = (comment.kidsObj || []).filter(isValidComment);\n    const commentText = comment.text || \"\";\n\n    if (!isValidComment(comment)) {\n      // kick out nothing if the comment was deleted and has no children\n      return null;\n    }\n\n    const childrenToShow = !isOpen ? null : (\n      <React.Fragment>\n        <p\n          className=\"comment\"\n          dangerouslySetInnerHTML={{ __html: commentText }}\n        />\n\n        {childComments.length > 0 && (\n          <HnCommentList\n            childComments={childComments}\n            depth={depth + 1}\n            onUpdateOpen={onUpdateOpen}\n            collapsedIds={collapsedIds}\n            idToScrollTo={idToScrollTo}\n            isSkeleton={false}\n          />\n        )}\n      </React.Fragment>\n    );\n\n    const borderColor = depth < colors.length ? colors[depth] : \"#bbb\";\n    return (\n      <div\n        className={classNames(\"bp3-card\", { collapsed: !isOpen })}\n        onClick={this.handleCardClick}\n        style={{\n          paddingLeft: 12 + Math.max(4 - depth),\n          marginLeft: 0,\n\n          borderLeftColor: borderColor,\n        }}\n      >\n        <p style={{ fontWeight: isOpen ? 450 : 300 }} ref={this.divRef}>\n          {comment.by}\n          {\" | \"}\n\n          {timeSince(comment.time)}\n          {\" ago\"}\n        </p>\n\n        {childrenToShow}\n      </div>\n    );\n  }\n  private handleCardClick = (e: React.MouseEvent<HTMLDivElement>) => {\n    const { comment, isOpen, onUpdateOpen, nextChildId } = this.props;\n\n    // this is to prevent other cards from collapsing too\n\n    e.stopPropagation();\n\n    // don't update state if click was A link\n    if ((e.target as any).tagName === \"A\") {\n      return;\n    }\n\n    // allow some gutter expansion once shifted over\n\n    const newIsOpen = !isOpen;\n\n    if (comment === null) {\n      return;\n    }\n\n    onUpdateOpen(comment.id, newIsOpen, undefined, comment, nextChildId);\n  };\n}\n\nexport function isValidComment(comment: KidsObj3 | null) {\n  // TODO: these items need to be removed somewhere else\n  if (comment === null) {\n    return false;\n  }\n  const isBad =\n    comment.deleted &&\n    (comment.kidsObj === undefined || comment.kidsObj.length === 0);\n\n  return !isBad;\n}\n","/Users/byronwall/Projects/hn-node/client/src/HnListItem.tsx",["79"],"import { Icon } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport { getDomain } from \"./getDomain\";\nimport { timeSince } from \"./timeSince\";\nimport { HnStorySummary } from \"./DataLayer\";\n\nexport interface HnStoryProps {\n  data: HnStorySummary;\n\n  isRead: boolean | undefined;\n}\n\nexport class HnListItem extends React.PureComponent<HnStoryProps> {\n  render() {\n    const { data: story, isRead } = this.props;\n\n    const commentCountNum =\n      story.commentCount ?? ((story as any).kids ?? []).length ?? \"\";\n    const commentCountComp = (\n      <React.Fragment>\n        {\" | \"}\n        <Link to={\"/story/\" + story.id}>\n          <Icon icon=\"comment\" /> {commentCountNum}\n        </Link>\n      </React.Fragment>\n    );\n\n    const storyLinkEl =\n      story.url === undefined ? (\n        <Link to={\"/story/\" + story.id}>{story.title}</Link>\n      ) : (\n        <a href={story.url} target=\"_blank\" rel=\"noreferrer\">\n          {story.title}\n        </a>\n      );\n\n    return (\n      <div className={classNames({ isRead })}>\n        <p>{storyLinkEl}</p>\n        <p>\n          <span>\n            <Icon icon=\"chevron-up\" /> {\" \" + story.score}\n          </span>\n          {commentCountNum !== \"\" && commentCountComp}\n          <span>{\" | \" + timeSince(story.time) + \" ago\"}</span>\n          <span>{\" | \" + getDomain(story.url)}</span>\n        </p>\n      </div>\n    );\n  }\n}\n","/Users/byronwall/Projects/hn-node/client/src/getDomain.tsx",[],"/Users/byronwall/Projects/hn-node/client/src/HnCommentList.tsx",[],"/Users/byronwall/Projects/hn-node/client/src/SearchPopup.tsx",[],"/Users/byronwall/Projects/hn-node/client/src/helpers.ts",[],"/Users/byronwall/Projects/hn-node/client/src/InfiniteScrollContainer.tsx",[],[],"/Users/byronwall/Projects/hn-node/client/src/timeSince.ts",[],{"ruleId":"80","severity":1,"message":"81","line":18,"column":33,"nodeType":"82","messageId":"83","endLine":18,"endColumn":36},{"ruleId":"80","severity":1,"message":"84","line":18,"column":38,"nodeType":"82","messageId":"83","endLine":18,"endColumn":44},{"ruleId":"80","severity":1,"message":"85","line":18,"column":46,"nodeType":"82","messageId":"83","endLine":18,"endColumn":54},{"ruleId":"80","severity":1,"message":"86","line":18,"column":56,"nodeType":"82","messageId":"83","endLine":18,"endColumn":61},{"ruleId":"87","severity":1,"message":"88","line":124,"column":19,"nodeType":"89","messageId":"90","endLine":124,"endColumn":21,"suggestions":"91"},{"ruleId":"87","severity":1,"message":"88","line":271,"column":47,"nodeType":"89","messageId":"90","endLine":271,"endColumn":49},{"ruleId":"87","severity":1,"message":"88","line":32,"column":26,"nodeType":"89","messageId":"90","endLine":32,"endColumn":65},{"ruleId":"92","severity":1,"message":"93","line":199,"column":25,"nodeType":"94","messageId":"95","endLine":199,"endColumn":28,"suggestions":"96"},{"ruleId":"92","severity":1,"message":"93","line":138,"column":22,"nodeType":"94","messageId":"95","endLine":138,"endColumn":25,"suggestions":"97"},{"ruleId":"92","severity":1,"message":"93","line":21,"column":40,"nodeType":"94","messageId":"95","endLine":21,"endColumn":43,"suggestions":"98"},"@typescript-eslint/no-unused-vars","'url' is defined but never used.","Identifier","unusedVar","'lineNo' is defined but never used.","'columnNo' is defined but never used.","'error' is defined but never used.","@typescript-eslint/no-non-null-assertion","Forbidden non-null assertion.","TSNonNullExpression","noNonNull",["99"],"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["100","101"],["102","103"],["104","105"],{"messageId":"106","fix":"107","desc":"108"},{"messageId":"109","fix":"110","desc":"111"},{"messageId":"112","fix":"113","desc":"114"},{"messageId":"109","fix":"115","desc":"111"},{"messageId":"112","fix":"116","desc":"114"},{"messageId":"109","fix":"117","desc":"111"},{"messageId":"112","fix":"118","desc":"114"},"suggestOptionalChain",{"range":"119","text":"120"},"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator.","suggestUnknown",{"range":"121","text":"122"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"121","text":"123"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"124","text":"122"},{"range":"124","text":"123"},{"range":"125","text":"122"},{"range":"125","text":"123"},[2861,2862],"?",[5144,5147],"unknown","never",[3282,3285],[565,568]]