{"version":3,"sources":["getDomain.tsx","HnCommentList.tsx","timeSince.tsx","HnComment.tsx","HnStoryPage.tsx","App.tsx","DataLayer.tsx","Header.tsx","HnListItem.tsx","HnStoryList.tsx","serviceWorker.ts","index.tsx"],"names":["getDomain","url","undefined","matches","match","HnCommentList","props","childRefs","childComments","forEach","item","id","React","createRef","validChildren","this","filter","comm","Fragment","map","childComm","index","key","comment","depth","canExpand","ref","onUpdateOpen","newOpen","scrollId","isOpen","collapsedIds","findIndex","c","idToScrollTo","Component","timeSince","date","seconds","Math","floor","Date","getTime","interval","colors","HnComment","divRef","state","expandSelf","scrollIfDesired","dims","current","offsetTop","console","log","window","scrollTo","behavior","top","kidsObj","isValidComment","commentText","text","childrenToShow","className","dangerouslySetInnerHTML","__html","length","newIsOpen","borderColor","classNames","collapsed","onClick","e","handleCardClick","style","paddingLeft","max","marginLeft","borderLeftColor","borderLeftWidth","borderRight","paddingRight","fontWeight","by","time","stopPropagation","target","tagName","gutterRatio","pageX","offsetLeft","innerWidth","setState","deleted","HnPage","HnListSource","HnStoryPage","collapsedComments","anchorClickHandler","bind","data","storyData","storyLinkEl","title","href","comments","document","overflowWrap","score","handleCollapseEvent","newIds","_","cloneDeep","remove","sessionStorage","setItem","JSON","stringify","concat","body","addEventListener","strCollapsedIds","getItem","parse","onVisitMarker","removeEventListener","link","history","push","preventDefault","DataLayer","pendingReadItems","initializeFromLocalStorage","isLoadingNewData","activeList","activeStory","isLoadingLocalStorage","readItems","activeListType","activeStoryId","localforage","saveIdToReadList","updateActiveList","updateActiveStory","pruneLocalStorage","keys","listProm","startsWith","Promise","all","storyLists","allKnownIds","flatten","keysToRemove","includes","removeItem","newReadList","prevState","getStoryFromServer","updateIsLoadingStatus","fetch","response","ok","error","json","isLoading","clearItemData","getStoryData","newStory","itemRemoved","itemsToCheck","strIds","collapseHash","Set","shift","has","delete","newCollapse","Array","from","source","summariesForType","reloadStoryListFromServer","dataOut","Front","sortBy","Day","Week","Month","updateNewItems","listType","storySummaries","commentCount","descendants","newAllItems","newDataList","story","Container","Header","marginBottom","Group","to","Heading","display","alignItems","src","color","activeClassName","align","size","intent","requestNewData","icon","minimal","PureComponent","HnListItem","isRead","HnStoryList","items","action","scrollPos","isNaN","scrollY","marginTop","readIds","_App","lastOpenTime","now","storyKey","activePage","STORY_LIST","storageUsed","onFocus","STORY","GLOBAL_DATA_LAYER","curTime","timeSinceInit","prevProps","didPageChange","didGoFromStoryToList","dataLayer","requestFreshDataFromDataLayer","reloadStoryById","hnPage","storyId","params","page","App","withRouter","isLocalhost","Boolean","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","smoothscroll","polyfill","onerror","msg","lineNo","columnNo","localForage","clear","innerHTML","localStorage","ReactDOM","render","path","inject","getElementById","URL","process","origin","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.5113bd3b.chunk.js","sourcesContent":["export function getDomain(url: string | undefined) {\n  if (url === undefined) {\n    return \"\";\n  }\n  var matches = url.match(/^https?\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i);\n  var domain = matches && matches[1];\n  return domain;\n}\n","import React from \"react\";\n\nimport { HnComment } from \"./HnComment\";\n\ninterface HnCommentListProps {\n  childComments: Array<KidsObj3 | null>;\n  depth: number;\n  canExpand: boolean;\n\n  onUpdateOpen(\n    id: number,\n    newOpen: boolean,\n    scrollId: number | undefined\n  ): void;\n\n  collapsedIds: number[];\n  idToScrollTo: number | undefined;\n}\n\nexport class HnCommentList extends React.Component<HnCommentListProps, {}> {\n  childRefs: Array<React.RefObject<HnComment>> = [];\n  constructor(props: HnCommentListProps) {\n    super(props);\n    props.childComments.forEach((item) => {\n      if (item === null) {\n        return;\n      }\n      this.childRefs[item.id] = React.createRef();\n    });\n  }\n  render() {\n    const validChildren = this.props.childComments.filter(\n      (comm) => comm !== null\n    );\n    return (\n      <React.Fragment>\n        {validChildren.map((childComm, index) => (\n          <HnComment\n            key={childComm!.id}\n            comment={childComm}\n            depth={this.props.depth}\n            canExpand={this.props.canExpand}\n            ref={this.childRefs[childComm!.id]}\n            onUpdateOpen={(id, newOpen, scrollId) =>\n              this.props.onUpdateOpen(\n                id,\n                newOpen,\n                scrollId ??\n                  (newOpen ? childComm?.id : validChildren[index + 1]?.id)\n              )\n            }\n            isOpen={\n              !(\n                this.props.collapsedIds.findIndex(\n                  (c) => childComm !== null && c === childComm.id\n                ) >= 0\n              )\n            }\n            collapsedIds={this.props.collapsedIds}\n            idToScrollTo={this.props.idToScrollTo}\n          />\n        ))}\n      </React.Fragment>\n    );\n  }\n}\n","export function timeSince(date: number) {\n  var seconds = Math.floor(new Date().getTime() / 1000 - date);\n  var interval = Math.floor(seconds / 31536000);\n  if (interval > 1) {\n    return interval + \" years\";\n  }\n  interval = Math.floor(seconds / 2592000);\n  if (interval > 1) {\n    return interval + \" months\";\n  }\n  interval = Math.floor(seconds / 86400);\n  if (interval > 1) {\n    return interval + \" days\";\n  }\n  interval = Math.floor(seconds / 3600);\n  if (interval >= 1) {\n    return interval + \" hour\" + (interval > 1 ? \"s\" : \"\");\n  }\n  interval = Math.floor(seconds / 60);\n  if (interval > 1) {\n    return interval + \" minutes\";\n  }\n  return Math.floor(seconds) + \" seconds\";\n}\n","import classNames from \"classnames\";\nimport React from \"react\";\n\nimport { HnCommentList } from \"./HnCommentList\";\nimport { timeSince } from \"./timeSince\";\n\nexport interface HnCommentProps {\n  comment: KidsObj3 | null;\n  depth: number;\n\n  canExpand: boolean;\n\n  isOpen: boolean;\n  onUpdateOpen(\n    id: number,\n    newIsOpen: boolean,\n    scrollId: number | undefined\n  ): void;\n  collapsedIds: number[];\n  idToScrollTo: number | undefined;\n}\n\ninterface HnCommentState {\n  expandSelf: boolean;\n}\n\nconst colors = [\n  \"#bc8672\",\n  \"#c5be53\",\n  \"#d46850\",\n  \"#8c7f3b\",\n  \"#dec392\",\n  \"#c9893a\",\n];\n\nexport class HnComment extends React.Component<HnCommentProps, HnCommentState> {\n  divRef: React.RefObject<HTMLDivElement>;\n\n  componentDidMount() {\n    this.scrollIfDesired();\n  }\n\n  componentDidUpdate() {\n    this.scrollIfDesired();\n  }\n\n  scrollIfDesired() {\n    if (this.props.idToScrollTo === this.props.comment?.id) {\n      const dims = this.divRef.current?.offsetTop;\n      console.log(\"scrolling to me\", dims);\n\n      if (dims !== undefined) {\n        window.scrollTo({ behavior: \"smooth\", top: dims - 80 });\n      }\n    }\n  }\n\n  static getDerivedStateFromProps(\n    props: HnCommentProps,\n    state: HnCommentState\n  ) {\n    // if a parent expands, collapse this one\n    if (!props.canExpand) {\n      return { expandSelf: false };\n    }\n\n    return null;\n  }\n\n  constructor(props: HnCommentProps) {\n    super(props);\n\n    this.state = {\n      expandSelf: false,\n    };\n\n    this.divRef = React.createRef();\n  }\n\n  getDivRef() {\n    return this.divRef.current!;\n  }\n\n  render() {\n    const comment = this.props.comment;\n\n    if (comment === null) {\n      return null;\n    }\n\n    const childComments = (comment.kidsObj || []).filter(isValidComment);\n    const commentText = comment.text || \"\";\n\n    if (!isValidComment(comment)) {\n      // kick out nothing if the comment was deleted and has no children\n      return null;\n    }\n\n    // TODO: rewrite links to hn to open in this site instead\n\n    const childrenToShow = !this.props.isOpen ? null : (\n      <React.Fragment>\n        <p\n          className=\"comment\"\n          dangerouslySetInnerHTML={{ __html: commentText }}\n        />\n\n        {childComments.length > 0 && (\n          <HnCommentList\n            childComments={childComments}\n            canExpand={this.props.canExpand && !this.state.expandSelf}\n            depth={this.props.depth + 1}\n            onUpdateOpen={(id, newIsOpen, scrollId) =>\n              this.props.onUpdateOpen(id, newIsOpen, scrollId)\n            }\n            collapsedIds={this.props.collapsedIds}\n            idToScrollTo={this.props.idToScrollTo}\n          />\n        )}\n      </React.Fragment>\n    );\n\n    const borderColor =\n      this.props.depth < colors.length ? colors[this.props.depth] : \"#bbb\";\n    return (\n      <div\n        className={classNames(\"bp3-card\", { collapsed: !this.props.isOpen })}\n        onClick={(e) => this.handleCardClick(e)}\n        style={{\n          paddingLeft: 12 + Math.max(4 - this.props.depth),\n          marginLeft:\n            this.state.expandSelf && this.props.isOpen\n              ? -17 * this.props.depth\n              : 0,\n\n          borderLeftColor: borderColor,\n\n          borderLeftWidth: this.state.expandSelf ? 6 : undefined,\n\n          borderRight: this.state.expandSelf\n            ? \"1px solid\" + borderColor\n            : undefined,\n          paddingRight: this.state.expandSelf ? 6 : undefined,\n        }}\n      >\n        <p\n          style={{ fontWeight: this.props.isOpen ? 450 : 300 }}\n          ref={this.divRef}\n        >\n          {comment.by}\n          {\" | \"}\n\n          {timeSince(comment.time)}\n          {\" ago\"}\n        </p>\n\n        {childrenToShow}\n      </div>\n    );\n  }\n  handleCardClick(e: React.MouseEvent<HTMLDivElement>): void {\n    // this is to prevent other cards from collapsing too\n\n    e.stopPropagation();\n\n    // dont update state if click was A link\n    if ((e.target as any).tagName === \"A\") {\n      return;\n    }\n\n    const target = e.target as any;\n\n    // allow some gutter expansion once shifted over\n    const gutterRatio = this.state.expandSelf ? 0.85 : 0.9;\n\n    if (\n      this.props.depth > 0 &&\n      this.props.canExpand &&\n      (e.pageX + target.offsetLeft) / window.innerWidth > gutterRatio\n    ) {\n      this.setState({ expandSelf: !this.state.expandSelf });\n    } else {\n      const isOpen = !this.props.isOpen;\n\n      if (this.props.comment === null) {\n        return;\n      }\n\n      this.props.onUpdateOpen(this.props.comment.id, isOpen, undefined);\n    }\n  }\n}\n\nexport function isValidComment(comment: KidsObj3 | null) {\n  if (comment === null) {\n    return false;\n  }\n  const isBad =\n    comment.deleted &&\n    (comment.kidsObj === undefined || comment.kidsObj!.length === 0);\n\n  return !isBad;\n}\n","import { H2, H4 } from \"@blueprintjs/core\";\nimport { History } from \"history\";\nimport _ from \"lodash\";\nimport React from \"react\";\n\nimport { getDomain } from \"./getDomain\";\nimport { isValidComment } from \"./HnComment\";\nimport { HnCommentList } from \"./HnCommentList\";\nimport { timeSince } from \"./timeSince\";\n\ninterface HnStoryPageState {\n  collapsedComments: number[];\n  idToScrollTo: number | undefined;\n}\n\nexport interface HnStoryPageProps {\n  data: HnItem | undefined;\n\n  id: number | undefined;\n  history: History;\n\n  onVisitMarker(id: number): void;\n}\n\nexport const SESSION_COLLAPSED = \"SESSION_COLLAPSED\";\nexport class HnStoryPage extends React.Component<\n  HnStoryPageProps,\n  HnStoryPageState\n> {\n  constructor(props: HnStoryPageProps) {\n    super(props);\n\n    this.state = {\n      collapsedComments: [],\n      idToScrollTo: undefined,\n    };\n\n    this.anchorClickHandler = this.anchorClickHandler.bind(this);\n  }\n\n  render() {\n    if (this.props.data === undefined) {\n      return null;\n    }\n\n    // add this line to remove the state info on scrolling -- prevent scroll on reload\n    if (this.state.idToScrollTo) {\n      this.setState({ idToScrollTo: undefined });\n    }\n\n    const storyData = this.props.data;\n\n    const storyLinkEl =\n      storyData.url === undefined ? (\n        <span>{storyData.title}</span>\n      ) : (\n        <a href={storyData.url}>{storyData.title}</a>\n      );\n\n    const comments = (storyData.kidsObj || []).filter(isValidComment);\n\n    document.title = `HN: ${storyData.title}`;\n\n    return (\n      <div>\n        <H2 style={{ overflowWrap: \"break-word\" }}>{storyLinkEl}</H2>\n        <H4>\n          <span>{storyData.by}</span>\n          <span>{\" | \"}</span>\n          <span>\n            {storyData.score}\n            {\" points\"}\n          </span>\n          <span>{\" | \"}</span>\n          <span>{timeSince(storyData.time)} ago</span>\n          <span>{\" | \"}</span>\n          <span>{getDomain(storyData.url)}</span>\n        </H4>\n        {storyData.text !== undefined && (\n          <p\n            className=\"top-text\"\n            dangerouslySetInnerHTML={{ __html: storyData.text }}\n          />\n        )}\n\n        <HnCommentList\n          childComments={comments}\n          canExpand={true}\n          depth={0}\n          collapsedIds={this.state.collapsedComments}\n          onUpdateOpen={(id, newOpen, scrollId) =>\n            this.handleCollapseEvent(id, newOpen, scrollId)\n          }\n          idToScrollTo={this.state.idToScrollTo}\n        />\n      </div>\n    );\n  }\n  handleCollapseEvent(\n    id: number,\n    newOpen: boolean,\n    scrollId: number | undefined\n  ): void {\n    // save the id to session storage\n\n    if (newOpen) {\n      // remove from list\n      const newIds = _.cloneDeep(this.state.collapsedComments);\n      _.remove(newIds, (c) => c === id);\n\n      sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newIds));\n      this.setState({ collapsedComments: newIds });\n    } else {\n      const newIds = this.state.collapsedComments.concat(id);\n\n      sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newIds));\n      this.setState({ collapsedComments: newIds });\n    }\n\n    if (scrollId !== undefined) {\n      this.setState({ idToScrollTo: scrollId });\n    }\n  }\n\n  componentDidMount() {\n    window.scrollTo({ top: 0 });\n\n    // set the data initially -- kick off async request if needed\n\n    document.body.addEventListener(\"click\", this.anchorClickHandler);\n\n    const strCollapsedIds = sessionStorage.getItem(SESSION_COLLAPSED);\n    // load the collapsed comments from session storage\n\n    if (strCollapsedIds !== null) {\n      const collapsedIds = JSON.parse(strCollapsedIds) as number[];\n\n      this.setState({ collapsedComments: collapsedIds });\n    }\n\n    // save the read stories to localForage\n\n    if (this.props.id !== undefined) {\n      this.props.onVisitMarker(this.props.id);\n    }\n  }\n\n  componentWillUnmount() {\n    document.body.removeEventListener(\"click\", this.anchorClickHandler);\n  }\n  anchorClickHandler(e: any) {\n    if (e.target.tagName !== \"A\") {\n      return;\n    }\n\n    // have a link\n\n    const link = e.target as HTMLAnchorElement;\n\n    const regex = /https?:\\/\\/news\\.ycombinator\\.com\\/item\\?id=(\\d+)/;\n    const matches = link.href.match(regex);\n\n    if (matches === null) {\n      link.target = \"_blank\";\n      return;\n    }\n\n    // this will navigate to the new page\n    this.props.history.push(\"/story/\" + matches[1]);\n\n    e.preventDefault();\n    return false;\n  }\n}\n","import \"./App.css\";\n\nimport React from \"react\";\nimport { RouteComponentProps, withRouter } from \"react-router\";\nimport { Subscribe } from \"unstated\";\n\nimport { GLOBAL_DATA_LAYER } from \".\";\nimport { DataLayer } from \"./DataLayer\";\nimport { Header } from \"./Header\";\nimport { HnStoryList } from \"./HnStoryList\";\nimport { HnStoryPage } from \"./HnStoryPage\";\n\ninterface AppPageProps\n  extends RouteComponentProps<{ page?: string; storyId?: string }> {}\n\nenum HnPage {\n  STORY_LIST,\n  STORY,\n}\n\nexport enum HnListSource {\n  Front,\n  Day,\n  Week,\n  Month,\n}\n\nexport type TrueHash = {\n  [key: number]: true;\n};\n\ninterface AppState {\n  activeList: HnListSource;\n  activePage: HnPage;\n  activeStoryId: number | undefined;\n\n  storyKey: number;\n\n  storageUsed: number;\n}\n\nclass _App extends React.Component<AppPageProps, AppState> {\n  lastOpenTime: number;\n  constructor(props: AppPageProps) {\n    super(props);\n\n    this.lastOpenTime = Date.now();\n\n    this.state = {\n      activeList: HnListSource.Front,\n      storyKey: 0,\n      activePage: HnPage.STORY_LIST,\n      activeStoryId: undefined,\n      storageUsed: 0,\n    };\n\n    this.onFocus = this.onFocus.bind(this);\n  }\n  static getDerivedStateFromProps(props: AppPageProps, state: AppState) {\n    let listType: HnListSource;\n    let hnPage: HnPage;\n    let storyId: number | undefined = undefined;\n\n    console.log(\"props page\", props.match.params.page);\n\n    const page =\n      props.match.params.storyId === undefined\n        ? props.match.params.page\n        : \"story\";\n\n    console.log(props.match, page);\n    switch (page) {\n      case \"day\":\n        listType = HnListSource.Day;\n        hnPage = HnPage.STORY_LIST;\n        break;\n\n      case \"week\":\n        listType = HnListSource.Week;\n        hnPage = HnPage.STORY_LIST;\n        break;\n\n      case \"month\":\n        listType = HnListSource.Month;\n        hnPage = HnPage.STORY_LIST;\n        break;\n\n      case \"story\":\n        hnPage = HnPage.STORY;\n        storyId = +(props.match.params.storyId ?? \"\");\n        listType = state.activeList;\n        break;\n\n      default:\n        listType = HnListSource.Front;\n        hnPage = HnPage.STORY_LIST;\n        break;\n    }\n\n    console.log(\"derived state\", props.match.params, listType, hnPage, storyId);\n\n    return {\n      activeList: listType,\n      activePage: hnPage,\n      activeStoryId: storyId,\n    };\n  }\n\n  async componentDidMount() {\n    // ensure that list and story are correct on a direct load\n    switch (this.state.activePage) {\n      case HnPage.STORY:\n        GLOBAL_DATA_LAYER.updateActiveStory(this.state.activeStoryId);\n        break;\n\n      case HnPage.STORY_LIST:\n        GLOBAL_DATA_LAYER.updateActiveList(this.state.activeList);\n        break;\n    }\n\n    this.lastOpenTime = Date.now();\n\n    window.addEventListener(\"focus\", this.onFocus);\n  }\n\n  componentWilUnmount() {\n    window.removeEventListener(\"focus\", this.onFocus);\n  }\n\n  onFocus() {\n    const curTime = Date.now();\n    const timeSinceInit = curTime - this.lastOpenTime;\n    console.log(\"time since init\", timeSinceInit, this.lastOpenTime, curTime);\n\n    // if it's been more than 1 minute\n    if (timeSinceInit > 20 * 1000) {\n      console.log(\n        \"been too long... force reload from local storage in case data changed on other tabs\"\n      );\n      GLOBAL_DATA_LAYER.initializeFromLocalStorage();\n    }\n\n    this.lastOpenTime = curTime;\n  }\n\n  async componentDidUpdate(prevProps: AppPageProps, prevState: AppState) {\n    const didPageChange = prevState.activeList !== this.state.activeList;\n    const didGoFromStoryToList =\n      prevState.activePage !== this.state.activePage &&\n      this.state.activePage === HnPage.STORY_LIST;\n\n    if (didPageChange || didGoFromStoryToList) {\n      // load the correct items from the data layer\n      GLOBAL_DATA_LAYER.updateActiveList(this.state.activeList);\n    }\n\n    const didStoryIdChange =\n      prevState.activeStoryId !== this.state.activeStoryId;\n\n    if (didStoryIdChange) {\n      GLOBAL_DATA_LAYER.updateActiveStory(this.state.activeStoryId);\n    }\n  }\n\n  render() {\n    return (\n      <Subscribe to={[DataLayer]}>\n        {(dataLayer: DataLayer) => (\n          <div>\n            <Header\n              requestNewData={() => this.requestFreshDataFromDataLayer()}\n              isLoading={dataLayer.state.isLoadingNewData}\n            />\n            {this.state.activePage === HnPage.STORY && (\n              <HnStoryPage\n                id={this.state.activeStoryId}\n                history={this.props.history}\n                key={this.state.activeStoryId + \"-\" + this.state.storyKey}\n                onVisitMarker={(id) => dataLayer.saveIdToReadList(id)}\n                data={dataLayer.state.activeStory}\n              />\n            )}\n            {this.state.activePage === HnPage.STORY_LIST && (\n              <HnStoryList\n                items={dataLayer.state.activeList}\n                readIds={dataLayer.state.readItems}\n                isLoading={dataLayer.state.isLoadingNewData}\n                history={this.props.history}\n              />\n            )}\n          </div>\n        )}\n      </Subscribe>\n    );\n  }\n  requestFreshDataFromDataLayer(): void {\n    switch (this.state.activePage) {\n      case HnPage.STORY:\n        if (this.state.activeStoryId !== undefined) {\n          console.log(\"reloading active story\");\n          GLOBAL_DATA_LAYER.reloadStoryById(this.state.activeStoryId);\n        }\n        break;\n      case HnPage.STORY_LIST:\n        console.log(\"reloading active list\");\n        GLOBAL_DATA_LAYER.reloadStoryListFromServer(this.state.activeList);\n        break;\n    }\n  }\n}\n\nexport const App = withRouter(_App);\n","import localforage from \"localforage\";\nimport _ from \"lodash\";\nimport { Container } from \"unstated\";\n\nimport { HnListSource, TrueHash } from \"./App\";\nimport { SESSION_COLLAPSED } from \"./HnStoryPage\";\n\ninterface DataLayerState {\n  activeListType: HnListSource | undefined;\n  activeStoryId: number | undefined;\n\n  activeList: HnStorySummary[];\n  activeStory: HnItem | undefined;\n\n  isLoadingNewData: boolean;\n  isLoadingLocalStorage: boolean;\n\n  readItems: TrueHash;\n}\n\nexport interface DataList {\n  key: HnListSource;\n\n  storyHeadlines: HnStorySummary[];\n}\n\nexport interface HnStorySummary {\n  title: string;\n  score: number;\n  id: number;\n  url: string | undefined;\n  commentCount: number | undefined;\n  time: number;\n}\n\nconst LOCAL_ALL_ITEMS = \"HN-ALL-ITEMS\";\nconst LOCAL_DATA_LISTS = \"HN-DATA-LISTS\";\nconst LOCAL_READ_ITEMS = \"STORAGE_READ_ITEMS\";\nexport class DataLayer extends Container<DataLayerState> {\n  pendingReadItems: number[] = [];\n\n  constructor() {\n    super();\n\n    // run through some initial stuff?\n\n    this.initializeFromLocalStorage();\n    // load from local storage on creation\n\n    this.state = {\n      isLoadingNewData: false,\n      activeList: [],\n      activeStory: undefined,\n      isLoadingLocalStorage: true,\n\n      readItems: {},\n      activeListType: undefined,\n      activeStoryId: undefined,\n    };\n  }\n\n  async initializeFromLocalStorage() {\n    console.log(\"loading from local storage\");\n    this.setState({ isLoadingLocalStorage: true });\n\n    // add the promise so that others can await them too\n\n    const readItems = await localforage.getItem<TrueHash>(LOCAL_READ_ITEMS);\n\n    console.log(\"loaded from local storage\");\n\n    this.setState({\n      isLoadingLocalStorage: false,\n      readItems: readItems ?? {},\n    });\n\n    this.pendingReadItems.forEach((id) => this.saveIdToReadList(id));\n    this.pendingReadItems = [];\n\n    if (this.state.activeListType !== undefined) {\n      this.updateActiveList(this.state.activeListType);\n    }\n\n    if (this.state.activeStoryId !== undefined) {\n      this.updateActiveStory(this.state.activeStoryId);\n    }\n\n    this.pruneLocalStorage();\n  }\n  async pruneLocalStorage() {\n    // this will go through the known lists and remove any stories that are not needed now\n\n    const keys = await localforage.keys();\n\n    const listProm = keys\n      .filter((key) => key.startsWith(\"STORIES_\"))\n      .map((key) => {\n        return localforage.getItem<HnStorySummary[]>(key);\n      });\n\n    const storyLists = await Promise.all(listProm);\n\n    const allKnownIds = _.flatten(storyLists).map((c) => c.id + \"\");\n\n    // remove those ids from the keys array above\n\n    const keysToRemove = keys\n      .filter((c) => !c.startsWith(\"STORIES_\"))\n      .filter((c) => !_.includes(allKnownIds, c));\n\n    console.log(\"going to prune\", keysToRemove);\n\n    keysToRemove.forEach((c) => localforage.removeItem(c));\n  }\n\n  saveIdToReadList(id: number): void {\n    if (this.state.isLoadingLocalStorage) {\n      // don't save data before list is loaded --- will clear it\n      console.log(\"do not update read list... pending updates\");\n      this.pendingReadItems.push(id);\n      return;\n    }\n    const newReadList = _.cloneDeep(this.state.readItems);\n    console.log(\"new read list\", newReadList);\n\n    // skip out if already there\n    if (newReadList[id]) {\n      return;\n    }\n\n    newReadList[id] = true;\n\n    localforage.setItem(LOCAL_READ_ITEMS, newReadList);\n\n    // ensure the new item is taken\n    this.setState((prevState) => {\n      return { readItems: newReadList };\n    });\n  }\n\n  async getStoryData(id: number) {\n    // load story from local storage or server\n    let item = localforage.getItem<HnItem>(id + \"\");\n    if (item !== null) {\n      return item;\n    }\n\n    // hit the API for the story data\n    return await this.getStoryFromServer(id);\n  }\n\n  public async getStoryFromServer(id: number) {\n    let url = \"/api/story/\" + id;\n\n    this.updateIsLoadingStatus(true);\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      return undefined;\n    }\n    const data: HnItem | { error: string } = await response.json();\n\n    if (\"error\" in data) {\n      console.error(data);\n      this.updateIsLoadingStatus(false);\n      return undefined;\n    }\n\n    console.log(\"hn item from server\", data);\n\n    this.updateIsLoadingStatus(false);\n\n    // ensure new story is saved locally\n    localforage.setItem(id + \"\", data);\n\n    return data;\n  }\n  updateIsLoadingStatus(isLoading: boolean) {\n    this.setState({ isLoadingNewData: isLoading });\n  }\n\n  async reloadStoryById(id: number) {\n    this.clearItemData(id);\n\n    const newStory = await this.getStoryData(id);\n    this.setState({ activeStory: newStory });\n  }\n\n  async clearItemData(id: number) {\n    const itemRemoved = await localforage.getItem<HnItem>(id + \"\");\n\n    if (itemRemoved === null) {\n      return;\n    }\n\n    await localforage.removeItem(id + \"\");\n\n    // need to clear any collpased ids also\n    if (itemRemoved !== undefined) {\n      // get all child ids\n\n      const itemsToCheck: (HnItem | KidsObj3)[] = [itemRemoved];\n\n      const strIds = sessionStorage.getItem(SESSION_COLLAPSED);\n\n      if (strIds !== null) {\n        const collapsedIds = JSON.parse(strIds) as number[];\n\n        const collapseHash = new Set(collapsedIds);\n\n        while (itemsToCheck.length) {\n          const item = itemsToCheck.shift();\n\n          if (item === undefined) {\n            continue;\n          }\n\n          // remove if collapsed\n          if (collapseHash.has(item.id)) {\n            collapseHash.delete(item.id);\n          }\n\n          item.kidsObj\n            ?.filter((c) => c !== null)\n            .forEach((c) => itemsToCheck.push(c!));\n        }\n\n        const newCollapse = Array.from(collapseHash);\n\n        console.log(\"old collapse\", collapsedIds, newCollapse);\n\n        sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newCollapse));\n      }\n    }\n  }\n\n  async updateActiveList(source: HnListSource) {\n    // TODO: add loading step if data is missing -- figure out how to trigger refresh\n\n    this.setState({ activeListType: source, activeList: [] });\n\n    console.log(\"getpagedata\", source, this.state);\n\n    if (source === undefined) {\n      console.error(\"unknown page -> source map\");\n      return [];\n    }\n\n    // load the story list from local storage if possible\n    const summariesForType = await localforage.getItem<HnStorySummary[]>(\n      \"STORIES_\" + source\n    );\n\n    if (summariesForType === null) {\n      console.log(\"no ids to load...\");\n      this.reloadStoryListFromServer(source);\n      return;\n    }\n\n    let dataOut = summariesForType;\n\n    if (source !== HnListSource.Front) {\n      dataOut = _.sortBy(dataOut, (c) => -c.score);\n    }\n\n    this.setState({ activeList: dataOut });\n  }\n\n  public async reloadStoryListFromServer(activeList: HnListSource) {\n    console.log(\"loading data\");\n    let url = \"\";\n    switch (activeList) {\n      case HnListSource.Front:\n        url = \"/topstories/topstories\";\n        break;\n      case HnListSource.Day:\n        url = \"/topstories/day\";\n        break;\n      case HnListSource.Week:\n        url = \"/topstories/week\";\n        break;\n      case HnListSource.Month:\n        url = \"/topstories/month\";\n        break;\n    }\n\n    if (this.state.isLoadingNewData) {\n      console.log(\"only have one request at a time\");\n      return;\n    }\n\n    this.updateIsLoadingStatus(true);\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      this.updateIsLoadingStatus(false);\n\n      return;\n    }\n    let data: HnItem[] = await response.json();\n\n    if (activeList !== HnListSource.Front) {\n      // flip score to get descending\n      data = _.sortBy<HnItem>(data, (c) => -c.score);\n    }\n\n    // TODO: take that list of items and set it equal to the current list\n    // TODO: update the items with a merge of sorts instead of overwriting\n\n    console.log(\"hn items from server\", data);\n\n    this.updateIsLoadingStatus(false);\n\n    this.updateNewItems(data, activeList);\n  }\n\n  updateNewItems(data: HnItem[] | undefined, listType: HnListSource): void {\n    console.log(\"items coming from server\", data, listType, this.state);\n\n    if (data === undefined) {\n      data = [];\n    }\n\n    // replace the list with the new IDs\n    const storySummaries: HnStorySummary[] = data.map<HnStorySummary>((c) => {\n      return {\n        id: c.id,\n        score: c.score,\n        title: c.title,\n        url: c.url,\n        commentCount: c.descendants,\n        time: c.time,\n      };\n    });\n\n    //  push each item in localforage under its own key\n\n    data.forEach((newStory) => {\n      localforage.setItem(newStory.id + \"\", newStory);\n    });\n\n    // also save the new list to localfoeage\n    localforage.setItem(\"STORIES_\" + listType, storySummaries);\n\n    // update otherwise\n\n    this.setState({\n      activeList: storySummaries,\n    });\n  }\n  saveNewDataToLocalStorage(newAllItems: HnItem[], newDataList: DataList[]) {\n    localforage.setItem(LOCAL_ALL_ITEMS, newAllItems);\n    localforage.setItem(LOCAL_DATA_LISTS, newDataList);\n  }\n\n  async updateActiveStory(activeStoryId: number | undefined) {\n    this.setState({ activeStoryId: activeStoryId });\n\n    if (activeStoryId === undefined) {\n      this.setState({ activeStory: undefined });\n      return;\n    }\n\n    const story = await this.getStoryData(activeStoryId);\n\n    this.setState({ activeStory: story });\n  }\n}\n","import { Button, Navbar, Spinner } from \"@blueprintjs/core\";\nimport React from \"react\";\nimport { Link, NavLink } from \"react-router-dom\";\n\ninterface HeaderProps {\n  requestNewData(): void;\n  isLoading: boolean;\n}\n\nexport class Header extends React.PureComponent<HeaderProps> {\n  render() {\n    return (\n      <Navbar style={{ marginBottom: 10 }}>\n        <Navbar.Group>\n          <Link to=\"/\" className=\"bp3-button bp3-minimal  header-link\">\n            <Navbar.Heading style={{ display: \"flex\", alignItems: \"center\" }}>\n              <img src=\"/favicon-32x32.png\" />\n              <span style={{ marginLeft: 3, color: \"#5C7080\" }}>offline</span>\n            </Navbar.Heading>\n          </Link>\n\n          <NavLink\n            to=\"/day\"\n            className=\"bp3-button bp3-minimal  header-link\"\n            activeClassName=\"bp3-active bp3-intent-primary\"\n          >\n            day\n          </NavLink>\n          <NavLink\n            to=\"/week\"\n            className=\"bp3-button bp3-minimal  header-link\"\n            activeClassName=\"bp3-active bp3-intent-primary\"\n          >\n            week\n          </NavLink>\n        </Navbar.Group>\n\n        <Navbar.Group align=\"right\">\n          {this.props.isLoading && <Spinner size={32} intent=\"warning\" />}\n          {!this.props.isLoading && (\n            <Button\n              intent=\"primary\"\n              onClick={() => this.props.requestNewData()}\n              icon=\"refresh\"\n              minimal={true}\n            />\n          )}\n        </Navbar.Group>\n      </Navbar>\n    );\n  }\n}\n","import { Icon } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport { getDomain } from \"./getDomain\";\nimport { timeSince } from \"./timeSince\";\nimport { HnStorySummary } from \"./DataLayer\";\n\nexport interface HnStoryProps {\n  data: HnStorySummary;\n\n  isRead: boolean | undefined;\n}\n\nexport class HnListItem extends React.Component<HnStoryProps> {\n  render() {\n    const story = this.props.data;\n\n    const commentCount = (\n      <React.Fragment>\n        {\" | \"}\n        <Link to={\"/story/\" + story.id}>\n          <Icon icon=\"comment\" /> {story.commentCount}\n        </Link>\n      </React.Fragment>\n    );\n\n    const storyLinkEl =\n      story.url === undefined ? (\n        <Link to={\"/story/\" + story.id}>{story.title}</Link>\n      ) : (\n        <a href={story.url} target=\"_blank\">\n          {story.title}\n        </a>\n      );\n\n    return (\n      <div className={classNames({ isRead: this.props.isRead })}>\n        <p>{storyLinkEl}</p>\n        <p>\n          <span>\n            <Icon icon=\"chevron-up\" /> {\" \" + story.score}\n          </span>\n          {story.commentCount !== undefined && commentCount}\n          <span>{\" | \" + timeSince(story.time) + \" ago\"}</span>\n          <span>{\" | \" + getDomain(story.url)}</span>\n        </p>\n      </div>\n    );\n  }\n}\n","import { Spinner } from \"@blueprintjs/core\";\nimport { History } from \"history\";\nimport React from \"react\";\n\nimport { TrueHash } from \"./App\";\nimport { HnListItem } from \"./HnListItem\";\nimport { HnStorySummary } from \"./DataLayer\";\n\ninterface HnStoryListProps {\n  items: HnStorySummary[];\n  readIds: TrueHash;\n  history: History;\n  isLoading: boolean;\n}\n\nconst SESSION_SCROLL = \"SCROLL_LIST\";\nexport class HnStoryList extends React.Component<HnStoryListProps> {\n  constructor(props: HnStoryListProps) {\n    super(props);\n    this.state = {\n      items: [],\n    };\n  }\n\n  componentDidMount() {\n    // TODO: get the types right for this\n    const history = this.props.history;\n    console.log(\"story list mount\", history);\n\n    if (history.action === \"POP\") {\n      // restore scroll pos if available\n      const scrollPos = +sessionStorage.getItem(SESSION_SCROLL)!;\n\n      if (!isNaN(scrollPos)) {\n        console.log(\"fire off scroll\", scrollPos);\n        window.scrollTo({ top: scrollPos });\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    console.log(\"save scroll pos\", window.scrollY);\n\n    sessionStorage.setItem(SESSION_SCROLL, \"\" + window.scrollY);\n  }\n\n  render() {\n    document.title = `HN: Offline`;\n\n    if (this.props.items.length === 0 && this.props.isLoading) {\n      return (\n        <div style={{ marginTop: 20 }}>\n          <Spinner size={200} intent=\"warning\" />\n        </div>\n      );\n    }\n\n    return (\n      <div>\n        {this.props.items\n          .filter((story) => story.commentCount !== undefined)\n          .map((item) => (\n            <HnListItem\n              data={item}\n              key={item.id}\n              isRead={this.props.readIds[item.id]}\n            />\n          ))}\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"@blueprintjs/core/lib/css/blueprint.css\";\n\nimport localForage from \"localforage\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter, Route } from \"react-router-dom\";\nimport smoothscroll from \"smoothscroll-polyfill\";\n\nimport { App } from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport { Provider } from \"unstated\";\nimport { DataLayer } from \"./DataLayer\";\n\n// kick off the polyfill!\nsmoothscroll.polyfill();\n\nwindow.onerror = function (msg, url, lineNo, columnNo, error) {\n  // ... handle error ...\n  console.error(\"major error\", msg);\n  localForage.clear();\n\n  document.body.innerHTML =\n    \"<h1>major error occurred.  local storage cleared to avoid corruption. please refresh.</h1>\";\n};\n\n// check if version exists\nconst version = localStorage.getItem(\"VERSION\");\nif (version === null) {\n  localForage.clear();\n}\n\nlocalStorage.setItem(\"VERSION\", \"1.0\");\n\nexport const GLOBAL_DATA_LAYER = new DataLayer();\n\nReactDOM.render(\n  <BrowserRouter>\n    <Route path={[\"/story/:storyId\", \"/:page?\"]}>\n      <Provider inject={[GLOBAL_DATA_LAYER]}>\n        <App />\n      </Provider>\n    </Route>\n  </BrowserRouter>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}