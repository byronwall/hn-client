{"version":3,"sources":["getDomain.tsx","HnCommentList.tsx","timeSince.tsx","HnComment.tsx","HnStoryPage.tsx","App.tsx","DataLayer.tsx","Header.tsx","HnListItem.tsx","HnStoryList.tsx","serviceWorker.ts","index.tsx"],"names":["getDomain","url","undefined","matches","match","HnCommentList","props","childRefs","childComments","forEach","item","id","React","createRef","validChildren","this","filter","comm","Fragment","map","childComm","index","key","comment","depth","canExpand","ref","onUpdateOpen","newOpen","scrollId","isOpen","collapsedIds","findIndex","c","idToScrollTo","Component","timeSince","date","seconds","Math","floor","Date","getTime","interval","colors","HnComment","divRef","state","expandSelf","scrollIfDesired","dims","current","offsetTop","console","log","window","scrollTo","behavior","top","kidsObj","isValidComment","commentText","text","childrenToShow","className","dangerouslySetInnerHTML","__html","length","newIsOpen","borderColor","classNames","collapsed","onClick","e","handleCardClick","style","paddingLeft","max","marginLeft","borderLeftColor","borderLeftWidth","borderRight","paddingRight","fontWeight","by","time","stopPropagation","target","tagName","gutterRatio","pageX","offsetLeft","innerWidth","setState","deleted","HnPage","HnListSource","HnStoryPage","collapsedComments","data","anchorClickHandler","bind","storyData","storyLinkEl","title","href","comments","document","overflowWrap","score","handleCollapseEvent","newIds","_","cloneDeep","remove","sessionStorage","setItem","JSON","stringify","concat","body","addEventListener","strCollapsedIds","getItem","parse","onVisitMarker","loadStoryData","prevProps","GLOBAL_DATA_LAYER","getStoryData","removeEventListener","link","history","push","preventDefault","DataLayer","pendingReadItems","initializeFromLocalStorage","isLoadingNewData","activeList","isLoadingLocalStorage","readItems","activeListType","storyKey","localforage","saveIdToReadList","updateActiveList","pruneLocalStorage","keys","listProm","startsWith","Promise","all","storyLists","allKnownIds","flatten","keysToRemove","includes","removeItem","newReadList","prevState","getStoryFromServer","updateIsLoadingStatus","fetch","response","ok","error","json","isLoading","clearItemData","itemRemoved","itemsToCheck","strIds","collapseHash","Set","shift","has","delete","newCollapse","Array","from","source","summariesForType","reloadStoryListFromServer","dataOut","Front","sortBy","Day","Week","Month","updateNewItems","listType","storySummaries","commentCount","descendants","newStory","Container","Header","marginBottom","Group","to","Heading","display","alignItems","src","color","activeClassName","align","size","intent","requestNewData","icon","minimal","PureComponent","HnListItem","story","isRead","HnStoryList","items","scrollToPrevious","action","scrollPos","isNaN","scrollY","spinner","marginTop","readIds","_App","lastOpenTime","now","activePage","STORY_LIST","activeStoryId","onFocus","curTime","timeSinceInit","didPageChange","didGoFromStoryToList","dataLayer","requestFreshDataFromDataLayer","STORY","reloadStoryById","hnPage","storyId","params","page","App","withRouter","isLocalhost","Boolean","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","smoothscroll","polyfill","onerror","msg","lineNo","columnNo","localForage","clear","innerHTML","localStorage","ReactDOM","render","path","inject","getElementById","URL","process","origin","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.51c4fc16.chunk.js","sourcesContent":["export function getDomain(url: string | undefined) {\n  if (url === undefined) {\n    return \"\";\n  }\n  var matches = url.match(/^https?\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i);\n  var domain = matches && matches[1];\n  return domain;\n}\n","import React from \"react\";\n\nimport { HnComment } from \"./HnComment\";\n\ninterface HnCommentListProps {\n  childComments: Array<KidsObj3 | null>;\n  depth: number;\n  canExpand: boolean;\n\n  onUpdateOpen(\n    id: number,\n    newOpen: boolean,\n    scrollId: number | undefined\n  ): void;\n\n  collapsedIds: number[];\n  idToScrollTo: number | undefined;\n}\n\nexport class HnCommentList extends React.Component<HnCommentListProps, {}> {\n  childRefs: Array<React.RefObject<HnComment>> = [];\n  constructor(props: HnCommentListProps) {\n    super(props);\n    props.childComments.forEach((item) => {\n      if (item === null) {\n        return;\n      }\n      this.childRefs[item.id] = React.createRef();\n    });\n  }\n  render() {\n    const validChildren = this.props.childComments.filter(\n      (comm) => comm !== null\n    );\n    return (\n      <React.Fragment>\n        {validChildren.map((childComm, index) => (\n          <HnComment\n            key={childComm!.id}\n            comment={childComm}\n            depth={this.props.depth}\n            canExpand={this.props.canExpand}\n            ref={this.childRefs[childComm!.id]}\n            onUpdateOpen={(id, newOpen, scrollId) =>\n              this.props.onUpdateOpen(\n                id,\n                newOpen,\n                scrollId ??\n                  (newOpen ? childComm?.id : validChildren[index + 1]?.id)\n              )\n            }\n            isOpen={\n              !(\n                this.props.collapsedIds.findIndex(\n                  (c) => childComm !== null && c === childComm.id\n                ) >= 0\n              )\n            }\n            collapsedIds={this.props.collapsedIds}\n            idToScrollTo={this.props.idToScrollTo}\n          />\n        ))}\n      </React.Fragment>\n    );\n  }\n}\n","export function timeSince(date: number) {\n  var seconds = Math.floor(new Date().getTime() / 1000 - date);\n  var interval = Math.floor(seconds / 31536000);\n  if (interval > 1) {\n    return interval + \" years\";\n  }\n  interval = Math.floor(seconds / 2592000);\n  if (interval > 1) {\n    return interval + \" months\";\n  }\n  interval = Math.floor(seconds / 86400);\n  if (interval > 1) {\n    return interval + \" days\";\n  }\n  interval = Math.floor(seconds / 3600);\n  if (interval >= 1) {\n    return interval + \" hour\" + (interval > 1 ? \"s\" : \"\");\n  }\n  interval = Math.floor(seconds / 60);\n  if (interval > 1) {\n    return interval + \" minutes\";\n  }\n  return Math.floor(seconds) + \" seconds\";\n}\n","import classNames from \"classnames\";\nimport React from \"react\";\n\nimport { HnCommentList } from \"./HnCommentList\";\nimport { timeSince } from \"./timeSince\";\n\nexport interface HnCommentProps {\n  comment: KidsObj3 | null;\n  depth: number;\n\n  canExpand: boolean;\n\n  isOpen: boolean;\n  onUpdateOpen(\n    id: number,\n    newIsOpen: boolean,\n    scrollId: number | undefined\n  ): void;\n  collapsedIds: number[];\n  idToScrollTo: number | undefined;\n}\n\ninterface HnCommentState {\n  expandSelf: boolean;\n}\n\nconst colors = [\n  \"#bc8672\",\n  \"#c5be53\",\n  \"#d46850\",\n  \"#8c7f3b\",\n  \"#dec392\",\n  \"#c9893a\",\n];\n\nexport class HnComment extends React.Component<HnCommentProps, HnCommentState> {\n  divRef: React.RefObject<HTMLDivElement>;\n\n  componentDidMount() {\n    this.scrollIfDesired();\n  }\n\n  componentDidUpdate() {\n    this.scrollIfDesired();\n  }\n\n  scrollIfDesired() {\n    if (this.props.idToScrollTo === this.props.comment?.id) {\n      const dims = this.divRef.current?.offsetTop;\n      console.log(\"scrolling to me\", dims);\n\n      if (dims !== undefined) {\n        window.scrollTo({ behavior: \"smooth\", top: dims - 80 });\n      }\n    }\n  }\n\n  static getDerivedStateFromProps(\n    props: HnCommentProps,\n    state: HnCommentState\n  ) {\n    // if a parent expands, collapse this one\n    if (!props.canExpand) {\n      return { expandSelf: false };\n    }\n\n    return null;\n  }\n\n  constructor(props: HnCommentProps) {\n    super(props);\n\n    this.state = {\n      expandSelf: false,\n    };\n\n    this.divRef = React.createRef();\n  }\n\n  getDivRef() {\n    return this.divRef.current!;\n  }\n\n  render() {\n    const comment = this.props.comment;\n\n    if (comment === null) {\n      return null;\n    }\n\n    const childComments = (comment.kidsObj || []).filter(isValidComment);\n    const commentText = comment.text || \"\";\n\n    if (!isValidComment(comment)) {\n      // kick out nothing if the comment was deleted and has no children\n      return null;\n    }\n\n    // TODO: rewrite links to hn to open in this site instead\n\n    const childrenToShow = !this.props.isOpen ? null : (\n      <React.Fragment>\n        <p\n          className=\"comment\"\n          dangerouslySetInnerHTML={{ __html: commentText }}\n        />\n\n        {childComments.length > 0 && (\n          <HnCommentList\n            childComments={childComments}\n            canExpand={this.props.canExpand && !this.state.expandSelf}\n            depth={this.props.depth + 1}\n            onUpdateOpen={(id, newIsOpen, scrollId) =>\n              this.props.onUpdateOpen(id, newIsOpen, scrollId)\n            }\n            collapsedIds={this.props.collapsedIds}\n            idToScrollTo={this.props.idToScrollTo}\n          />\n        )}\n      </React.Fragment>\n    );\n\n    const borderColor =\n      this.props.depth < colors.length ? colors[this.props.depth] : \"#bbb\";\n    return (\n      <div\n        className={classNames(\"bp3-card\", { collapsed: !this.props.isOpen })}\n        onClick={(e) => this.handleCardClick(e)}\n        style={{\n          paddingLeft: 12 + Math.max(4 - this.props.depth),\n          marginLeft:\n            this.state.expandSelf && this.props.isOpen\n              ? -17 * this.props.depth\n              : 0,\n\n          borderLeftColor: borderColor,\n\n          borderLeftWidth: this.state.expandSelf ? 6 : undefined,\n\n          borderRight: this.state.expandSelf\n            ? \"1px solid\" + borderColor\n            : undefined,\n          paddingRight: this.state.expandSelf ? 6 : undefined,\n        }}\n      >\n        <p\n          style={{ fontWeight: this.props.isOpen ? 450 : 300 }}\n          ref={this.divRef}\n        >\n          {comment.by}\n          {\" | \"}\n\n          {timeSince(comment.time)}\n          {\" ago\"}\n        </p>\n\n        {childrenToShow}\n      </div>\n    );\n  }\n  handleCardClick(e: React.MouseEvent<HTMLDivElement>): void {\n    // this is to prevent other cards from collapsing too\n\n    e.stopPropagation();\n\n    // dont update state if click was A link\n    if ((e.target as any).tagName === \"A\") {\n      return;\n    }\n\n    const target = e.target as any;\n\n    // allow some gutter expansion once shifted over\n    const gutterRatio = this.state.expandSelf ? 0.85 : 0.9;\n\n    if (\n      this.props.depth > 0 &&\n      this.props.canExpand &&\n      (e.pageX + target.offsetLeft) / window.innerWidth > gutterRatio\n    ) {\n      this.setState({ expandSelf: !this.state.expandSelf });\n    } else {\n      const isOpen = !this.props.isOpen;\n\n      if (this.props.comment === null) {\n        return;\n      }\n\n      this.props.onUpdateOpen(this.props.comment.id, isOpen, undefined);\n    }\n  }\n}\n\nexport function isValidComment(comment: KidsObj3 | null) {\n  if (comment === null) {\n    return false;\n  }\n  const isBad =\n    comment.deleted &&\n    (comment.kidsObj === undefined || comment.kidsObj!.length === 0);\n\n  return !isBad;\n}\n","import { H2, H4 } from \"@blueprintjs/core\";\nimport { History } from \"history\";\nimport _ from \"lodash\";\nimport React from \"react\";\n\nimport { GLOBAL_DATA_LAYER } from \".\";\nimport { getDomain } from \"./getDomain\";\nimport { isValidComment } from \"./HnComment\";\nimport { HnCommentList } from \"./HnCommentList\";\nimport { timeSince } from \"./timeSince\";\n\ninterface HnStoryPageState {\n  collapsedComments: number[];\n  idToScrollTo: number | undefined;\n\n  data: HnItem | undefined | null;\n}\n\nexport interface HnStoryPageProps {\n  id: number | undefined;\n  history: History;\n\n  onVisitMarker(id: number): void;\n}\n\nexport const SESSION_COLLAPSED = \"SESSION_COLLAPSED\";\nexport class HnStoryPage extends React.Component<\n  HnStoryPageProps,\n  HnStoryPageState\n> {\n  constructor(props: HnStoryPageProps) {\n    super(props);\n\n    this.state = {\n      collapsedComments: [],\n      idToScrollTo: undefined,\n      data: undefined,\n    };\n\n    this.anchorClickHandler = this.anchorClickHandler.bind(this);\n  }\n\n  render() {\n    if (!this.state.data) {\n      return null;\n    }\n\n    // add this line to remove the state info on scrolling -- prevent scroll on reload\n    if (this.state.idToScrollTo) {\n      this.setState({ idToScrollTo: undefined });\n    }\n\n    const storyData = this.state.data;\n\n    const storyLinkEl =\n      storyData.url === undefined ? (\n        <span>{storyData.title}</span>\n      ) : (\n        <a href={storyData.url}>{storyData.title}</a>\n      );\n\n    const comments = (storyData.kidsObj || []).filter(isValidComment);\n\n    document.title = `HN: ${storyData.title}`;\n\n    return (\n      <div>\n        <H2 style={{ overflowWrap: \"break-word\" }}>{storyLinkEl}</H2>\n        <H4>\n          <span>{storyData.by}</span>\n          <span>{\" | \"}</span>\n          <span>\n            {storyData.score}\n            {\" points\"}\n          </span>\n          <span>{\" | \"}</span>\n          <span>{timeSince(storyData.time)} ago</span>\n          <span>{\" | \"}</span>\n          <span>{getDomain(storyData.url)}</span>\n        </H4>\n        {storyData.text !== undefined && (\n          <p\n            className=\"top-text\"\n            dangerouslySetInnerHTML={{ __html: storyData.text }}\n          />\n        )}\n\n        <HnCommentList\n          childComments={comments}\n          canExpand={true}\n          depth={0}\n          collapsedIds={this.state.collapsedComments}\n          onUpdateOpen={(id, newOpen, scrollId) =>\n            this.handleCollapseEvent(id, newOpen, scrollId)\n          }\n          idToScrollTo={this.state.idToScrollTo}\n        />\n      </div>\n    );\n  }\n  handleCollapseEvent(\n    id: number,\n    newOpen: boolean,\n    scrollId: number | undefined\n  ): void {\n    // save the id to session storage\n\n    if (newOpen) {\n      // remove from list\n      const newIds = _.cloneDeep(this.state.collapsedComments);\n      _.remove(newIds, (c) => c === id);\n\n      sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newIds));\n      this.setState({ collapsedComments: newIds });\n    } else {\n      const newIds = this.state.collapsedComments.concat(id);\n\n      sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newIds));\n      this.setState({ collapsedComments: newIds });\n    }\n\n    if (scrollId !== undefined) {\n      this.setState({ idToScrollTo: scrollId });\n    }\n  }\n\n  componentDidMount() {\n    window.scrollTo({ top: 0 });\n\n    // set the data initially -- kick off async request if needed\n\n    document.body.addEventListener(\"click\", this.anchorClickHandler);\n\n    const strCollapsedIds = sessionStorage.getItem(SESSION_COLLAPSED);\n    // load the collapsed comments from session storage\n\n    if (strCollapsedIds !== null) {\n      const collapsedIds = JSON.parse(strCollapsedIds) as number[];\n\n      this.setState({ collapsedComments: collapsedIds });\n    }\n\n    // save the read stories to localForage\n\n    if (this.props.id !== undefined) {\n      this.props.onVisitMarker(this.props.id);\n    }\n\n    // load the story data\n\n    this.loadStoryData();\n  }\n\n  componentDidUpdate(prevProps: HnStoryPageProps) {\n    const didIdChange = this.props.id !== prevProps.id;\n\n    if (didIdChange) {\n      this.loadStoryData();\n    }\n  }\n\n  async loadStoryData() {\n    // take the ID, get the story, send to state\n\n    // TODO: why is this ever undefined?\n\n    if (this.props.id === undefined) {\n      return;\n    }\n\n    const storyData = await GLOBAL_DATA_LAYER.getStoryData(this.props.id);\n\n    this.setState({ data: storyData });\n  }\n\n  componentWillUnmount() {\n    document.body.removeEventListener(\"click\", this.anchorClickHandler);\n  }\n  anchorClickHandler(e: any) {\n    if (e.target.tagName !== \"A\") {\n      return;\n    }\n\n    // have a link\n\n    const link = e.target as HTMLAnchorElement;\n\n    const regex = /https?:\\/\\/news\\.ycombinator\\.com\\/item\\?id=(\\d+)/;\n    const matches = link.href.match(regex);\n\n    if (matches === null) {\n      link.target = \"_blank\";\n      return;\n    }\n\n    // this will navigate to the new page\n    this.props.history.push(\"/story/\" + matches[1]);\n\n    e.preventDefault();\n    return false;\n  }\n}\n","import \"./App.css\";\n\nimport React from \"react\";\nimport { RouteComponentProps, withRouter } from \"react-router\";\nimport { Subscribe } from \"unstated\";\n\nimport { GLOBAL_DATA_LAYER } from \".\";\nimport { DataLayer } from \"./DataLayer\";\nimport { Header } from \"./Header\";\nimport { HnStoryList } from \"./HnStoryList\";\nimport { HnStoryPage } from \"./HnStoryPage\";\n\ninterface AppPageProps\n  extends RouteComponentProps<{ page?: string; storyId?: string }> {}\n\nenum HnPage {\n  STORY_LIST,\n  STORY,\n}\n\nexport enum HnListSource {\n  Front,\n  Day,\n  Week,\n  Month,\n}\n\nexport type TrueHash = {\n  [key: number]: true;\n};\n\ninterface AppState {\n  activeList: HnListSource;\n  activePage: HnPage;\n  activeStoryId: number | undefined;\n}\n\nclass _App extends React.Component<AppPageProps, AppState> {\n  lastOpenTime: number;\n  constructor(props: AppPageProps) {\n    super(props);\n\n    this.lastOpenTime = Date.now();\n\n    this.state = {\n      activeList: HnListSource.Front,\n\n      activePage: HnPage.STORY_LIST,\n      activeStoryId: undefined,\n    };\n\n    this.onFocus = this.onFocus.bind(this);\n  }\n  static getDerivedStateFromProps(props: AppPageProps, state: AppState) {\n    let listType: HnListSource;\n    let hnPage: HnPage;\n    let storyId: number | undefined = undefined;\n\n    console.log(\"props page\", props.match.params.page);\n\n    const page =\n      props.match.params.storyId === undefined\n        ? props.match.params.page\n        : \"story\";\n\n    console.log(props.match, page);\n    switch (page) {\n      case \"day\":\n        listType = HnListSource.Day;\n        hnPage = HnPage.STORY_LIST;\n        break;\n\n      case \"week\":\n        listType = HnListSource.Week;\n        hnPage = HnPage.STORY_LIST;\n        break;\n\n      case \"month\":\n        listType = HnListSource.Month;\n        hnPage = HnPage.STORY_LIST;\n        break;\n\n      case \"story\":\n        hnPage = HnPage.STORY;\n        storyId = +(props.match.params.storyId ?? \"\");\n        listType = state.activeList;\n        break;\n\n      default:\n        listType = HnListSource.Front;\n        hnPage = HnPage.STORY_LIST;\n        break;\n    }\n\n    console.log(\"derived state\", props.match.params, listType, hnPage, storyId);\n\n    return {\n      activeList: listType,\n      activePage: hnPage,\n      activeStoryId: storyId,\n    };\n  }\n\n  async componentDidMount() {\n    // ensure that list and story are correct on a direct load\n    if (this.state.activePage === HnPage.STORY_LIST) {\n      GLOBAL_DATA_LAYER.updateActiveList(this.state.activeList);\n    }\n\n    this.lastOpenTime = Date.now();\n\n    window.addEventListener(\"focus\", this.onFocus);\n  }\n\n  componentWilUnmount() {\n    window.removeEventListener(\"focus\", this.onFocus);\n  }\n\n  onFocus() {\n    const curTime = Date.now();\n    const timeSinceInit = curTime - this.lastOpenTime;\n    console.log(\"time since init\", timeSinceInit, this.lastOpenTime, curTime);\n\n    // if it's been more than 1 minute\n    if (timeSinceInit > 20 * 1000) {\n      console.log(\n        \"been too long... force reload from local storage in case data changed on other tabs\"\n      );\n      GLOBAL_DATA_LAYER.initializeFromLocalStorage();\n    }\n\n    this.lastOpenTime = curTime;\n  }\n\n  async componentDidUpdate(prevProps: AppPageProps, prevState: AppState) {\n    const didPageChange = prevState.activeList !== this.state.activeList;\n    const didGoFromStoryToList =\n      prevState.activePage !== this.state.activePage &&\n      this.state.activePage === HnPage.STORY_LIST;\n\n    if (didPageChange || didGoFromStoryToList) {\n      // load the correct items from the data layer\n      GLOBAL_DATA_LAYER.updateActiveList(this.state.activeList);\n    }\n  }\n\n  render() {\n    console.log(\"app render\", window.scrollY);\n    return (\n      <Subscribe to={[DataLayer]}>\n        {(dataLayer: DataLayer) => (\n          <div>\n            <Header\n              requestNewData={() => this.requestFreshDataFromDataLayer()}\n              isLoading={dataLayer.state.isLoadingNewData}\n            />\n            {this.state.activePage === HnPage.STORY && (\n              <HnStoryPage\n                id={this.state.activeStoryId}\n                history={this.props.history}\n                key={this.state.activeStoryId + \"-\" + dataLayer.state.storyKey}\n                onVisitMarker={(id) => dataLayer.saveIdToReadList(id)}\n              />\n            )}\n            {this.state.activePage === HnPage.STORY_LIST && (\n              <HnStoryList\n                items={dataLayer.state.activeList}\n                readIds={dataLayer.state.readItems}\n                isLoading={dataLayer.state.isLoadingNewData}\n                history={this.props.history}\n              />\n            )}\n          </div>\n        )}\n      </Subscribe>\n    );\n  }\n  requestFreshDataFromDataLayer(): void {\n    switch (this.state.activePage) {\n      case HnPage.STORY:\n        if (this.state.activeStoryId !== undefined) {\n          console.log(\"reloading active story\");\n          GLOBAL_DATA_LAYER.reloadStoryById(this.state.activeStoryId);\n        }\n        break;\n      case HnPage.STORY_LIST:\n        console.log(\"reloading active list\");\n        GLOBAL_DATA_LAYER.reloadStoryListFromServer(this.state.activeList);\n        break;\n    }\n  }\n}\n\nexport const App = withRouter(_App);\n","import localforage from \"localforage\";\nimport _ from \"lodash\";\nimport { Container } from \"unstated\";\n\nimport { HnListSource, TrueHash } from \"./App\";\nimport { SESSION_COLLAPSED } from \"./HnStoryPage\";\n\ninterface DataLayerState {\n  activeListType: HnListSource | undefined;\n\n  activeList: HnStorySummary[];\n\n  isLoadingNewData: boolean;\n  isLoadingLocalStorage: boolean;\n\n  readItems: TrueHash;\n\n  storyKey: number;\n}\n\nexport interface DataList {\n  key: HnListSource;\n\n  storyHeadlines: HnStorySummary[];\n}\n\nexport interface HnStorySummary {\n  title: string;\n  score: number;\n  id: number;\n  url: string | undefined;\n  commentCount: number | undefined;\n  time: number;\n}\n\nconst LOCAL_READ_ITEMS = \"STORAGE_READ_ITEMS\";\nexport class DataLayer extends Container<DataLayerState> {\n  pendingReadItems: number[] = [];\n\n  constructor() {\n    super();\n\n    // run through some initial stuff?\n\n    this.initializeFromLocalStorage();\n    // load from local storage on creation\n\n    this.state = {\n      isLoadingNewData: false,\n      activeList: [],\n\n      isLoadingLocalStorage: true,\n\n      readItems: {},\n      activeListType: undefined,\n\n      storyKey: 0,\n    };\n  }\n\n  async initializeFromLocalStorage() {\n    console.log(\"loading from local storage\");\n    this.setState({ isLoadingLocalStorage: true });\n\n    // add the promise so that others can await them too\n\n    const readItems = await localforage.getItem<TrueHash>(LOCAL_READ_ITEMS);\n\n    console.log(\"loaded from local storage\");\n\n    this.setState({\n      isLoadingLocalStorage: false,\n      readItems: readItems ?? {},\n    });\n\n    this.pendingReadItems.forEach((id) => this.saveIdToReadList(id));\n    this.pendingReadItems = [];\n\n    if (this.state.activeListType !== undefined) {\n      this.updateActiveList(this.state.activeListType);\n    }\n\n    this.pruneLocalStorage();\n  }\n  async pruneLocalStorage() {\n    // this will go through the known lists and remove any stories that are not needed now\n\n    const keys = await localforage.keys();\n\n    const listProm = keys\n      .filter((key) => key.startsWith(\"STORIES_\"))\n      .map((key) => {\n        return localforage.getItem<HnStorySummary[]>(key);\n      });\n\n    const storyLists = await Promise.all(listProm);\n\n    const allKnownIds = _.flatten(storyLists).map((c) => c.id + \"\");\n\n    // remove those ids from the keys array above\n\n    const keysToRemove = keys\n      .filter((c) => !c.startsWith(\"STORIES_\"))\n      .filter((c) => c !== LOCAL_READ_ITEMS)\n      .filter((c) => !_.includes(allKnownIds, c));\n\n    console.log(\"going to prune\", keysToRemove);\n\n    keysToRemove.forEach((c) => localforage.removeItem(c));\n  }\n\n  saveIdToReadList(id: number): void {\n    if (this.state.isLoadingLocalStorage) {\n      // don't save data before list is loaded --- will clear it\n      console.log(\"do not update read list... pending updates\");\n      this.pendingReadItems.push(id);\n      return;\n    }\n    const newReadList = _.cloneDeep(this.state.readItems);\n    console.log(\"new read list\", newReadList);\n\n    // skip out if already there\n    if (newReadList[id]) {\n      return;\n    }\n\n    newReadList[id] = true;\n\n    localforage.setItem(LOCAL_READ_ITEMS, newReadList);\n\n    // ensure the new item is taken\n    this.setState((prevState) => {\n      return { readItems: newReadList };\n    });\n  }\n\n  async getStoryData(id: number) {\n    // load story from local storage or server\n    let item = await localforage.getItem<HnItem>(id + \"\");\n\n    if (item !== null) {\n      return item;\n    }\n\n    // hit the API for the story data\n    return await this.getStoryFromServer(id);\n  }\n\n  public async getStoryFromServer(id: number) {\n    let url = \"/api/story/\" + id;\n\n    this.updateIsLoadingStatus(true);\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      return undefined;\n    }\n    const data: HnItem | { error: string } = await response.json();\n\n    if (\"error\" in data) {\n      console.error(data);\n      this.updateIsLoadingStatus(false);\n      return undefined;\n    }\n\n    console.log(\"hn item from server\", data);\n\n    this.updateIsLoadingStatus(false);\n\n    // ensure new story is saved locally\n    localforage.setItem(id + \"\", data);\n\n    return data;\n  }\n  updateIsLoadingStatus(isLoading: boolean) {\n    this.setState({ isLoadingNewData: isLoading });\n  }\n\n  async reloadStoryById(id: number) {\n    await this.clearItemData(id);\n\n    // this should force a render of the story page\n    this.setState((prevState) => {\n      return { storyKey: prevState.storyKey + 1 };\n    });\n  }\n\n  async clearItemData(id: number) {\n    const itemRemoved = await localforage.getItem<HnItem>(id + \"\");\n\n    if (itemRemoved === null) {\n      return;\n    }\n\n    await localforage.removeItem(id + \"\");\n\n    // need to clear any collpased ids also\n    if (itemRemoved !== undefined) {\n      // get all child ids\n\n      const itemsToCheck: (HnItem | KidsObj3)[] = [itemRemoved];\n\n      const strIds = sessionStorage.getItem(SESSION_COLLAPSED);\n\n      if (strIds !== null) {\n        const collapsedIds = JSON.parse(strIds) as number[];\n\n        const collapseHash = new Set(collapsedIds);\n\n        while (itemsToCheck.length) {\n          const item = itemsToCheck.shift();\n\n          if (item === undefined) {\n            continue;\n          }\n\n          // remove if collapsed\n          if (collapseHash.has(item.id)) {\n            collapseHash.delete(item.id);\n          }\n\n          item.kidsObj\n            ?.filter((c) => c !== null)\n            .forEach((c) => itemsToCheck.push(c!));\n        }\n\n        const newCollapse = Array.from(collapseHash);\n\n        console.log(\"old collapse\", collapsedIds, newCollapse);\n\n        sessionStorage.setItem(SESSION_COLLAPSED, JSON.stringify(newCollapse));\n      }\n    }\n  }\n\n  async updateActiveList(source: HnListSource) {\n    // TODO: add loading step if data is missing -- figure out how to trigger refresh\n\n    this.setState({ activeListType: source });\n\n    console.log(\"getpagedata\", source, this.state);\n\n    if (source === undefined) {\n      console.error(\"unknown page -> source map\");\n      this.setState({ activeList: [] });\n      return [];\n    }\n\n    // load the story list from local storage if possible\n    const summariesForType = await localforage.getItem<HnStorySummary[]>(\n      \"STORIES_\" + source\n    );\n\n    if (summariesForType === null) {\n      console.log(\"no ids to load...\");\n      this.reloadStoryListFromServer(source);\n      return;\n    }\n\n    let dataOut = summariesForType;\n\n    if (source !== HnListSource.Front) {\n      dataOut = _.sortBy(dataOut, (c) => -c.score);\n    }\n\n    this.setState({ activeList: dataOut });\n  }\n\n  public async reloadStoryListFromServer(activeList: HnListSource) {\n    console.log(\"loading data\");\n    let url = \"\";\n    switch (activeList) {\n      case HnListSource.Front:\n        url = \"/topstories/topstories\";\n        break;\n      case HnListSource.Day:\n        url = \"/topstories/day\";\n        break;\n      case HnListSource.Week:\n        url = \"/topstories/week\";\n        break;\n      case HnListSource.Month:\n        url = \"/topstories/month\";\n        break;\n    }\n\n    if (this.state.isLoadingNewData) {\n      console.log(\"only have one request at a time\");\n      return;\n    }\n\n    this.updateIsLoadingStatus(true);\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      console.error(response);\n      this.updateIsLoadingStatus(false);\n\n      return;\n    }\n    let data: HnItem[] = await response.json();\n\n    if (activeList !== HnListSource.Front) {\n      // flip score to get descending\n      data = _.sortBy<HnItem>(data, (c) => -c.score);\n    }\n\n    // TODO: take that list of items and set it equal to the current list\n    // TODO: update the items with a merge of sorts instead of overwriting\n\n    console.log(\"hn items from server\", data);\n\n    this.updateIsLoadingStatus(false);\n\n    this.updateNewItems(data, activeList);\n  }\n\n  updateNewItems(data: HnItem[] | undefined, listType: HnListSource): void {\n    console.log(\"items coming from server\", data, listType, this.state);\n\n    if (data === undefined) {\n      data = [];\n    }\n\n    // replace the list with the new IDs\n    const storySummaries: HnStorySummary[] = data.map<HnStorySummary>((c) => {\n      return {\n        id: c.id,\n        score: c.score,\n        title: c.title,\n        url: c.url,\n        commentCount: c.descendants,\n        time: c.time,\n      };\n    });\n\n    //  push each item in localforage under its own key\n\n    data.forEach((newStory) => {\n      localforage.setItem(newStory.id + \"\", newStory);\n    });\n\n    // also save the new list to localfoeage\n    localforage.setItem(\"STORIES_\" + listType, storySummaries);\n\n    // update otherwise\n\n    this.setState({\n      activeList: storySummaries,\n    });\n  }\n}\n","import { Button, Navbar, Spinner } from \"@blueprintjs/core\";\nimport React from \"react\";\nimport { Link, NavLink } from \"react-router-dom\";\n\ninterface HeaderProps {\n  requestNewData(): void;\n  isLoading: boolean;\n}\n\nexport class Header extends React.PureComponent<HeaderProps> {\n  render() {\n    return (\n      <Navbar style={{ marginBottom: 10 }}>\n        <Navbar.Group>\n          <Link to=\"/\" className=\"bp3-button bp3-minimal  header-link\">\n            <Navbar.Heading style={{ display: \"flex\", alignItems: \"center\" }}>\n              <img src=\"/favicon-32x32.png\" />\n              <span style={{ marginLeft: 3, color: \"#5C7080\" }}>offline</span>\n            </Navbar.Heading>\n          </Link>\n\n          <NavLink\n            to=\"/day\"\n            className=\"bp3-button bp3-minimal  header-link\"\n            activeClassName=\"bp3-active bp3-intent-primary\"\n          >\n            day\n          </NavLink>\n          <NavLink\n            to=\"/week\"\n            className=\"bp3-button bp3-minimal  header-link\"\n            activeClassName=\"bp3-active bp3-intent-primary\"\n          >\n            week\n          </NavLink>\n        </Navbar.Group>\n\n        <Navbar.Group align=\"right\">\n          {this.props.isLoading && <Spinner size={32} intent=\"warning\" />}\n          {!this.props.isLoading && (\n            <Button\n              intent=\"primary\"\n              onClick={() => this.props.requestNewData()}\n              icon=\"refresh\"\n              minimal={true}\n            />\n          )}\n        </Navbar.Group>\n      </Navbar>\n    );\n  }\n}\n","import { Icon } from \"@blueprintjs/core\";\nimport classNames from \"classnames\";\nimport React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport { getDomain } from \"./getDomain\";\nimport { timeSince } from \"./timeSince\";\nimport { HnStorySummary } from \"./DataLayer\";\n\nexport interface HnStoryProps {\n  data: HnStorySummary;\n\n  isRead: boolean | undefined;\n}\n\nexport class HnListItem extends React.Component<HnStoryProps> {\n  render() {\n    const story = this.props.data;\n\n    const commentCount = (\n      <React.Fragment>\n        {\" | \"}\n        <Link to={\"/story/\" + story.id}>\n          <Icon icon=\"comment\" /> {story.commentCount}\n        </Link>\n      </React.Fragment>\n    );\n\n    const storyLinkEl =\n      story.url === undefined ? (\n        <Link to={\"/story/\" + story.id}>{story.title}</Link>\n      ) : (\n        <a href={story.url} target=\"_blank\">\n          {story.title}\n        </a>\n      );\n\n    return (\n      <div className={classNames({ isRead: this.props.isRead })}>\n        <p>{storyLinkEl}</p>\n        <p>\n          <span>\n            <Icon icon=\"chevron-up\" /> {\" \" + story.score}\n          </span>\n          {story.commentCount !== undefined && commentCount}\n          <span>{\" | \" + timeSince(story.time) + \" ago\"}</span>\n          <span>{\" | \" + getDomain(story.url)}</span>\n        </p>\n      </div>\n    );\n  }\n}\n","import { Spinner } from \"@blueprintjs/core\";\nimport { History } from \"history\";\nimport React from \"react\";\n\nimport { TrueHash } from \"./App\";\nimport { HnListItem } from \"./HnListItem\";\nimport { HnStorySummary } from \"./DataLayer\";\n\ninterface HnStoryListProps {\n  items: HnStorySummary[];\n  readIds: TrueHash;\n  history: History;\n  isLoading: boolean;\n}\n\nconst SESSION_SCROLL = \"SCROLL_LIST\";\nexport class HnStoryList extends React.PureComponent<HnStoryListProps> {\n  constructor(props: HnStoryListProps) {\n    super(props);\n    this.state = {\n      items: [],\n    };\n  }\n\n  componentDidMount() {\n    this.scrollToPrevious();\n  }\n\n  private scrollToPrevious() {\n    const history = this.props.history;\n\n    if (history.action === \"POP\") {\n      // restore scroll pos if available\n      const scrollPos = +sessionStorage.getItem(SESSION_SCROLL)!;\n\n      if (!isNaN(scrollPos)) {\n        console.log(\"fire off scroll\", scrollPos);\n        window.scrollTo({ top: scrollPos });\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    console.log(\"save scroll pos\", window.scrollY);\n\n    sessionStorage.setItem(SESSION_SCROLL, \"\" + window.scrollY);\n  }\n\n  render() {\n    document.title = `HN: Offline`;\n\n    const spinner =\n      this.props.items.length === 0 && this.props.isLoading ? (\n        <div style={{ marginTop: 20 }}>\n          <Spinner size={200} intent=\"warning\" />\n        </div>\n      ) : null;\n\n    return (\n      <div>\n        {spinner}\n        <div>\n          {this.props.items\n            .filter((story) => story.commentCount !== undefined)\n            .map((item) => (\n              <HnListItem\n                data={item}\n                key={item.id}\n                isRead={this.props.readIds[item.id]}\n              />\n            ))}\n        </div>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"@blueprintjs/core/lib/css/blueprint.css\";\n\nimport localForage from \"localforage\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { BrowserRouter, Route } from \"react-router-dom\";\nimport smoothscroll from \"smoothscroll-polyfill\";\n\nimport { App } from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nimport { Provider } from \"unstated\";\nimport { DataLayer } from \"./DataLayer\";\n\n// kick off the polyfill!\nsmoothscroll.polyfill();\n\nwindow.onerror = function (msg, url, lineNo, columnNo, error) {\n  // ... handle error ...\n  console.error(\"major error\", msg);\n  localForage.clear();\n\n  document.body.innerHTML =\n    \"<h1>major error occurred.  local storage cleared to avoid corruption. please refresh.</h1>\";\n};\n\n// check if version exists\nconst version = localStorage.getItem(\"VERSION\");\nif (version === null) {\n  localForage.clear();\n}\n\nlocalStorage.setItem(\"VERSION\", \"1.0\");\n\nexport const GLOBAL_DATA_LAYER = new DataLayer();\n\nReactDOM.render(\n  <BrowserRouter>\n    <Route path={[\"/story/:storyId\", \"/:page?\"]}>\n      <Provider inject={[GLOBAL_DATA_LAYER]}>\n        <App />\n      </Provider>\n    </Route>\n  </BrowserRouter>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}